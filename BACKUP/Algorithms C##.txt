When answering interview questions
	always focus on requirements. Ask more, assume it will be difficult every single time
	Try and avoid recurcion.
	Don't use brute force approach (storing all possible variations beforehand)

Linear Time Complexity 0(n)
	Regular Loops

Log Time Complexity
	Binary search

Binary Search
	Start at middle index or left side of middle index
		if middle == target then return
		if middl > target then search(left), otherwise search left
			Middle of that slice
			check again

	Implementation
		recursive
			if start > end {
				not found
			}
			const middle = Math.Floor( (start + end) / 2 );

			if(arr[middle] === target){
				return found it ...
			}

			if(arr[middle] > target){
				return findMe(target, start, middle-1) - So now it searches to the left of the original search
			}

			if(arr[middle] < target){
				return findMe(target, middle+1, end) - So now it searches to the right of the original search
			}
		While loop
			left = 0
			right = arr.length - 1

			while (left <= right)
				int mid = (left + right) / 2

				if(arr[mid] == target)
				{
					return mid;
				}
				else if (arr[mid] < target)
				{
					left = mid + 1;
				}
				else
				{
					right = mid - 1;
				}
			}

			return -1; if not found in search range

Sliding Window
	Expand window from start until finding target value
		if sliding value is greater than target - Window shrinks one element from the left and checks again
		Found it? Cool!
		Now it can keep going to find the other values aswell
	Everytime value is over target, it shrinks from left
	Everytime value is under target, it expands to right

	There is the Fixed Length Variant
		max sum Subarray of size K
	The Dynamic Variant
		smallest sum >= to some Value S
	Dynamic Variant w Auxillary data structure (hash)
		Longest substring w no more than k distinct characters
		String Permutations

	Implementation
		Fixed length
			findMaxSub(arr, int searchSize)
			maxValue = 0
			currSum = 0

			for(0 -> arr.length){
				currentSum += arr[i];
				if(i >= searchSize - 1){ - Once 3 elements selected
					maxValue = Math.max(maxValue, currentSum); - Return the max sum
					currentSum -= arr[i - (searchSize - 1)] - Deletes the first arr[i] value so it can run the += again with next right value and check once more
				}
			}
			return maxValue;
		Dynamic Variant
			SmallestSubArrayGivenSum(arr, targetSum)

				int minSearchSize = int.MaxValue; 
				int startIndex = 0
				currSum = 0

				for(i -> arr.length){
					currSum += arr[i];
					
					while(i >= targetSum){ - CUrrent sum is now equal to the target value
						minSearchSize = Math.min(minSearchSize, i - startIndex + 1) - This gives us the size(delta) of how large our window is currently
						currSum -= arr[startIndex]; - Deletes the first arr[i] value
						i++; - Keep growing
					}
				}

				return minSearchSize;
		Dynamic Variant auxillary 
			kdistinctFindLength(str, k)

				int windowStart = 0;
				int maxLength = 0;
		        Dictionary<char, int> charFrequencyMap = new Dictionary<char, int>();

		        for (int i = 0; i < str.Length; i++)
		        {
		            char rightChar = str[i];

		            if (charFrequencyMap.ContainsKey(rightChar)){
		                charFrequencyMap[rightChar]++;
		            }
		            else{
		                charFrequencyMap[rightChar] = 1;
		            }

		            while (charFrequencyMap.Count > k)
		            {
		                char leftChar = str[windowStart];

		                charFrequencyMap[leftChar]--;

		                if (charFrequencyMap[leftChar] == 0){
		                    charFrequencyMap.Remove(leftChar);
		                }

		                windowStart++;
		            }

		            maxLength = Math.Max(maxLength, i - windowStart + 1);
		        }
		        return maxLength;


Linked List
	Single Linked List - Forward navigation only
		node[data, link] - Actual data, link to address of next node in the list
	Doubly Linked List - Forward and backwards navigation
	Circular Linked List - Last element is linked to the first element

	Implementation
Depth For Search
Breath For Search
Stack
Two Pointers
Arrays & Hashing/HashMaps
Trees
Heap & Priority Queue
Recursion