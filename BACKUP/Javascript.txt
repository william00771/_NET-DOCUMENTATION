JS Does not care about defining data - Sucks.
No Alternatives to Javascript in the browser
Behind The Scenes
	JS Engine - JS is single-threaded
		Heap - Long Term Data
		Stack - Execution Context, The short term memory
		CallStack - What excecutes in order
		Event Loop - Helps with async functions, event listeners e.t.c. stores it in a temp loop
		General Flow - Script Parsing -> Interpreter -> bytecode/Browser APIs -> Compiler (JiT) -> Machine Code
		Memory / Garbage collector - Throws away unused data, attributes
			Beware of memory leaks where you still hold references to objects that are not being used anymore.
	primitive vs reference values
		primitive - All vars of different types (normally exists in the stack)
		reference - All other Objects like arrays, objects. More expensive to create (Normally stored in Heap)

Setup
	Simple HTML5 Template or Just run js directly in vscode using Code Runner Extension
	<script src="location"> </script> - use script at head of HTML body with DEFER
		defer - defer inside script tag means load scripts as parsing is happening (They Load Faster)
		async - If script does not rely on html, just use async

Classes - (A Blueprint, a class has data & methods)
Constructors - (a special method that lets you initialize values in a class)
Derived Class (Dependency) - (Make a class inherit properties from a base class)
Dependency Injection - (Creates a dependency to another class inside a given class, so you can use the external classes properties)
Methods - (A function inside a class, object)
Interfaces - (A contract that allows certain methods between user and class/struct)
Promises - (In javascript Promisess are async commands that return a promise)
Enum - (A class that describes a custom set of attributes)

Declarations
	Fields - Do not exist in Javascript, but do exists in Typescript
	Declare class/interfaces(do not exist in javascript)
		class Name extends DerivefromName {} - (Derives from a certain base)
		class Name {
			constructor(val1, val2, val3){this.val1 = val1}
			render(){ - ClassMethods
				...
			}
		}
		Initiating other classes in a class
			ObjectsBasedOnOtherClass = [new ClassName(val1,val2,)]
			new Name(){
				pass values in...
			}
			OBS classes work exactly like normal objects so you can use all functions that you can on objects
				
	Declare Constructors - You can skip Props entierly and just use this inside class
		constructor(RenderHookId){
			super(RenderHookId); - It calls the base class constructor (the inheritance class) and passes RenderHookId in, you always have to call it first
		}
	Declare Props
		Inside Constructor
			constructor(title, image, desc, product) {
				this.title = title;
				this.image = image;
				this.description = desc;
				this.product = product;
			}
	Declare Methods
		render() { inside class then classname.render - This is a method that renders stuff using dom
			use this.description to refeer
		}

		Static class methods
			static init() {} - So you don't have instantiate the class to refeer to the method
				so you can write Class.init instead of declaring it first. To share functionality across apps
		If you write this.render inside the constructor of the base class, then all classes will run their version of 
			this.render if overriden inside those classes. This way you can save alot of class.render(). Calls since it across all classes always calls this.render
	Declare Props
		Name;
		title = 'DEFAULT';
		set name(val) {validation... this._name = val} - Ex check if its empty and if so set a default value, or always converting to uppercase for example formatting
		get name(val) {validation... return this._name} - Add transform when getting a value for example, like datetime formatting ex
	Declare functions
		function Name(input1, input2) {return returntype} - Return can break out of the function
			Name(1, Object);
		const Name = function(input1, input2) {return returntype}
			Name(1, Object);
		const Name = (input1, input2) => {return returntype} - Arrow functions are better. cool features
			Name(2, Object);
		You can skip the return keyword and curly braces if you write a turnary expression ex:
			const getWinner = (input1, input2) => 
				input1 === input2 ? ... : ...;
			const add = (a + b) => a + b; - same as return a + b ONLY works with ONE EXPRESSION
		.functionName('param', Function as argument/code to excecute)
		If we have no other place in our code we will use that function again, Declare it anonomous
			function() {...} 
		this refers to this parent function. Arrow function does not have this so then it accessses the parent.
	Declare methods - methods are functions inside an object
		const person = { name: 'Bob', renderCharacter: function renderCharacter(){...} }
	Declare Variable - "block scope is the correct clean way to write code around" 
		const Name = 
			const by default. Never use var.
		let Name = 
			Is always scoped within the brace.
		Symbols - uid They always have uniqueness to them, used for object property identifiers
			const uid = Symbol('uid');
			const user = {
				[uid]: 'p1' - Now p1 cannot be changed or accessed Unique id that cant be accidentally overwritten
			}
			Can only be changed inside libary user[uid] = 'p3'
	Declare certaint properties for model variables/props
		[Key] - (Generates a Keyattribute for you)
		[Required] - (Variable is required in the data)
	Declare certain properties for methods
	Declare Objects
		const objectName = {Value1: something, Value2: 'something', Value3: Object, info: {name: 'Bob'}}
		objectName.Value1
		{
			functionName() {
				return this. ...
			}
		}
		(The core data structure in javascript to reflect "real-world" entities)
			[extraname] = extraValue - assign a dynamic property (in this case refeering to the const "extraname" which can be dom element and extravalue which is also a dom element)
			title (is the same as title = title;)
			Good example structure for object
	Declare Arrays
		const Name = [value1, value2, value3]
			ArrayName[0] - Refeers to 1st element
		const Name = new Array(length) - Creates an empty array with a specific length
		const Name = new Array.from() - Takes an arraylike object as input
			Mixed data in arrays is totally acceptable
		const Name = [[1, 1.6], [-5.4, 2.1]] - Multidimentional arrays
			index 0 1 2 3 4 5
	Declare Sets
		const ids = new Set(); - Can be array, setlist e.t.c.
		const persons = new WeakSet(); - Weak can only store Objects, Can release to garbage collector person=null.
		ids.has(1);
		(duplicates not allowed, order NOT guaranteed, GREAT FOR UNIQUENESS in data, ex for ids)
	Declare Maps
		const mapData = new Map([[person1, [{date: 'yesterday', price: 10}]]]);
		const personData = new WeakMap(); - Weak can only store Objects, Can release to garbage collector person=null.
		(store key-value data, use anything as a key, order IS guaranteed)
		(Better performance for large quantities of data)
		(better performance when adding / removing data frequently)

Destructuring
	const options ={
		foo: true,
		bar: false
	}
	const {foo, bar} = options;

Dependency Injection 
	You just use it in the class, you don't need dependency injection
	
Syntax
	Function syntax: (functions ARE special types of objects with properties)
	use "mode" as function input to dynamically set values and not repeat yourself
		function writeLog(   - Use handler in lastname if it handles a event and then functions inside
			input1,
			input2,
			input3,
			input4,
		)  {
			const logEentry = {
				Name1: input1,
				Name2: input2 ....
			};
			logEntries.push(logEntry);
			return result
		}

		Assigning default values to functions (input1, input2 = 1) - Default Value IS 1
		Some functions REQUIRE a callback function to work

	Callback Functions
		sumUp(Result, 1, 5, 10, 15) - The showResult function runs THROUGH the sumUp function

		const sumUp = (CallbackFunctionName, ...inputs) => {
			...dosomethingwithinputs
			CallbackFunctionName(sumofInputs); - Excecutes the function resultHandler
		}

		FunctionName = (result) => {
			...printresults or something
		}

	Rest Operator
		(...inputs) - It BUILDS an array called inputs based on number of inputs - Use in function input
		Access the array using a for of loop and do something with them. 

	Spread Operator
		{...person} - Pulls out all the INDIVIDUAL elements of an array and writes (value1, value2, value3, value4)
		Math.min(...prices) To take all array values and converts them into (value1, value2, value3, value4) format
		You copy items of the array
		Creates a brand new array. The objects in the array are however still a reference to the old objects in the old array.
		const object2 = { ...person}; copies over all person values into a new object HOWEVER SAME REFERENCE to old object
		.assign({}, person) - same as {...person}

		To Actually Duplicate an object use JSON.Stringify() and JSON.parse() - You can create a copy and then duplicate that
		const newObj = JSON.parse(JSON.stringify(oldObj))

	Bind Operator
		In Callbackfunctions where you CANNOT put in inputs you CAN using bind. 
			addEventListener('click', functionName.bind(this or null, input1, input2){})
		callbackfunctioncall.bind(this, input1, input2)
		inside function inputs (bindinputscomethroughhere, allotherinputscomethroughhere, operation)

		functioninsideobject = functioninsideobject.bind(movie) - Explicitly tells the function what object to refeer to

	This and functions inside objects (ex getFormattedTitle)
		OBS Be careful think about what this refeers to based on function(p) or arrow function
		OBS Arrow don't change the binding of this.
		this - looks into the object that this function is a part of. So this.info refeers to this specific object info
			   look at the thing that is responsible for excecuting that function
			   Its always the thing in front of that function
			   ALWAYS REFEERS TO THE THING CALLING THE FUNCTION, if NOTHING is in front it becomes the GLOBAL
		ex inside object
			GetFormattedTitle() {
				return this.info.title.toUpperCase();
			}
			const members = {
			    teamName: 'Blue Rockets',
			    people: ['Max','Manuel'],
			    getTeamMembers() {
			        this.people.forEach((p) => {
			            console.log(p + ' - ' + this.teamName);
			        })
			    }
			}
			function(p) {} would NOT work in here because the function BINDS the keyword this to that specific functioncall, NOT the object itself

	Prototype Objects == "Fallback Objects" - Important since All of Javascript works like this
		It checks the blueprint itself
		Then checks the prototype
		Then checks the prototype of the prototype (only exists on function objects)
		Then the underlying base invincible prototype __proto__
		You can setup functions inside that fallback object using .prototype
		Person.prototype = {printAge() {...}} - Makes it accessible from the prototype object

	If Else statement/expression
		if(== != === !== < > && || !){} else if{} else{}
		Return inside an if statement to get out of the function and not excecute anymore code.
		const userName = isLogin ? 'Max' : null - Ternary operator
		 return condition1 ? value1
			    : condition2 ? value2
			    : condition3 ? value3
			    : value4;
		const userName = isLogin === 'admin' ? true : false - Ternary operator
		const name = Input || 'Max' - If first Input is falsy assign 'Max'
		const name = Input && 'Max' - If first Input is true assign 'Max'
		!! to convert truthy, falsy to boolean true/false

	Switch statement - if you dont ad break then it goes through all the cases
		switch(ev){
			case LOG_EVENT_1:
				...
				break;
			default:
				...
		}

	Loops (For loop, for-of loop, forin loop, while loop)
		starts on the i value, stops BEFORE the maxvalue - used alot with .length

		can use commands inside loops
			break; - Force a Break out of the loop
			continue; - Forces the next iteration of the loop, so to skip this iteration of the loop
			loopName: do{} and then break loopName - Used to break out of outer loop, more than one

		for loop
			for (let i = 1; i < 3; i++){
				console.log(i);
			}

		
		for-of arrays
			for (const element of array){
				console.log(element);
			}
			(let i = 0; + i++ inside to get index)

			for (const product of this.products){
				console.log(product);
			}

		for-in Objects
			for (const item in object) {
				console.log(item);
				console.log(object[item]);
			}
			for (const key in movie.info){
				if (key !== 'title'){
					text = text + `${key}: ${movie.info[key]}`;
				}
			}
				Goes through a specific key value inside a specific part of an object, very useful!

		while loop
			while (isLoggedIn){
				...
			}

		do while loop (excecute BEFORE checking the condition, so always once)
			do {

			} while (isloggedInChanged)

		Example of finding the keys of objects stored in an array
			let i = 0;
			for (const element of objects){
			    console.log(`#${i}`);
			    for (const item in element){
			        console.log(item);
			        console.log(element[item]); 
			    }
			    i++;
			}

		Object adding dynamic properties
			const userChosenKeyName = 'dynamic values...';

			let person = {
				[userChosenKeyName]: '...',
			}

	Tagged Templates - Makes you easily replace an input string with dynamic value with values spit out from function

		const productOutput = Name`This Product (${productName}) is ${productName} and ${productPrice} marvelous`

		function Name(strings, productName, productPrice){
			return `${strings[0]}${productName}${strings[1]}${productPrice}${strings[2]}`
		}


	RegEx - Fantastic for Validation / Validating input
		const regex = *expression*
		regex.test(userInput) - Returns true if correct


Callbacks & Promises when Calling Functions
	Callbacks (The OLD way):
		someAsyncTask(() => {
			setTimeOut(() => {
				DoMoreStuff(() => {

				});
			}, 1000);
		} ...);
	Promises (The NEW way): - .then excecutes whenever the promise resolves and has run through the code
		someAsyncTask()
			.then(data => {...}, error => {})
			.then(() => {...})
			.then(...)
			.catch(error => {});
	Normally:
		functionName(data => {...}, error => {...}, timeoutOrSomething => {...})
	You can have Callbacks inside of callbacks ex 
		data => { setTimeout(() => {...}, 2000); }
	Avoiding Callback hell - create your own promises from callbacks - Look at the different results the callback might need/return
		const setTimer = (duration) => {
			const promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve();
				}, duration OR error => {}, options? => {})
			});
			return promise;
		};
	Promise Chaining Example
		let pos;
		getPosition()
			.then(posData => {
				pos = posData;
				return setTimer(); - Passes promise to the next part of the chain
			})
			.then(data => {
				console.log(data, pos);
			});


Error Handling
	Throw and try-catch
		throw {message: 'Invalid user input'} - You can throw your own error

		try{
			...try this and catch any error that might happen
		}
		catch(err){
			...console.log(err), setDefaultValue / report to user e.t.c.
			throw err; - To throw it to our own servers
		} finally{
			... - Code block to be executed regardless of the try result
		}

	Promise Error handling
		.then(resolve => {}, error => {})
		OR
		.then(resolve => {}).catch(error => {}

		The catch block catches any error in the chain above it

		const getPosition = opts => {
			const promise = new Promise((resolve, reject) => {
				navigator.geolocation.getCurrentPosition(
					success => {
						resolve(success);
					},
					error => {
						reject(error);
					},
					options
				);
			});
			return promise;
		};
	

Dependency Injection 

Convert syncronous to asyncronous (Single threaded to multi threaded)
	DOM API has an ongoing timer, message queue - holds the calls, Event Loop runs is the stack empty or todos?
	the function automatically returns a promise With the Async keyword - It wraps the entire function in a promise
	Use await in front of every promise
	Await works like an invisible .then block. Its the same but shorter.
		It acts as a temporary pause in the code. Without it the different parts of the code would run simontanously

		const funtionName = async () => {
			const posData = await getPosition();
			const timeData = await setTimer(2000);
			console.log(timeData, posData);
		}
		async function functionName(){
			
		}

Error handling
	let posData;
	let timeData;
	try {
		posData = await getPosition();
		timeData = await setTimer(2000);
	}
	catch(error) {
		console.log(error);
	}
	console.log(timeData, posData);

	If you want to run promises simultaneously
		Promise.race([promise1, promise2]).then(data => {}) - It returns the fastest promise
		Promise.all([promise1, promise2]).then(promisedata => {}) - Returns all of the promise data as an array
		Promise.allSettled([promise1, promise2]).then(promisedata => {}) - You can see more detailed description, which promises failed and which ones succeeded

Expressions
	Lambda Expression
		x => x.*
	Truthy falsy (useful for evaluations)
		!var1 - returns false if 0 and true if 1
		0 = false
		empty string = false
		any number incl negative = true
		any non empty string = true
		objects, arrays = true
		null, undefined, NaN = false
		
		!! - Use two ecsclamation mark when Converting Truthy falsy value to a real boolean

Building class based DOM manipulation project
	use App class with function static init() {...}
	run App.init(); in application
	Declare different classes with different selectors inside the constructor(type){...}


Javascript Modules - Split everything up into files, folders
	CORS - Cross origin reserve policies is needed to run javascript modules. You can use npm serve package. Really great because dependencies are managed . This IS the standard in js applications
	Every file is its own scope
	inside html file use type="module" when importing the App.js
	Exporting
		export *
		export default * - The default export has no name assigned so you assign it on the import
	Importing
		import { exact function/class to import, *} from 'file.ext'; ../goes up one path ./same folder /root
		import * as Name from 'file.ext' - Bundles multible exports together into one import
		import { Name as newName} - To give a new allias
		import customName from 'file.ext' - Imports a default, you declare the name
	Dynamic Imports and Code splitting - If you know the code will not always be needed
		import('./file.ext').then => (module => {
			...use the file ex module.toolTip
		})
		Makes you download certain things only when you need them
	Code inside modules only run once the first time they are loaded. Not the 2nd time

Working with URLS


Browser Functions
	Nodes - Objects that make up the dom
		Element nodes - html tags
		Text nodes - text
		attribute nodes - attributes assigned to html tags
	Elements
		Special properties and methods to interact with the elements
		console.dir(element) - to check the element parameters/functionsd

	document - DOM Related - The top most entry point. Document object model, DOM parses HTML
		Dataset attributes
			Declare: data-id, data-name, data-whatever
			.dataset.attribute - To get dataset values
			.dataset.Addedinfo = 'extrainfo' - To add dataset values in js
		Template
			<template> ...htmlcontent... <template/> - add html content that doesn't imidiately get rendered
			template = document.importNode(selectTemplateId.content, true); - Creates a copy of a node or documentfragment from another document, to then be inserted into the document later. You u9se this paired with appendChild() and insertBefore() insertAdjacentElement()
			.append(template) - onto somewhere in the html document
			- Perfect for managing long snippets of html code IN THE html file itself instead of the js file
		.body, .header
		.querySelector('#name or .name') - Returns first index of that item, all css selectors (less performance)
		the most powerful way of selecting elements
			Dynamic Selector: ("div#" + id); - Id being the input in the function
			:first-of-type
			:last-of-type
			:first-child 
			:last-child
			:nth-child(x)
			:nth-of-type(x) - All these commands have a slight performance impact
			
			.firstElementChild - Selects the first child
			.lastElementChild - Selects the last child
			.children[x] - All child nodes that are based of html tags
			.parentElementNode - Nearest Parent Node
			.previousElementSibling - Selects the previous <> group that is not nested in the current grouping
			.nextElementSibling - Selects the next <> group that is not nested in the current grouping
			
			.firstChild - Selects the first child from ALL childs
			.lastChild - Selects the last child from ALL childs
			.childNodes[x] - Selects ALL child linebreaks, text and nodes
			.parentNode - Selects parent
			.previousSibling -
			.nextSibling - 
		.querySelectorAll('name') - Returns array of all matching items, all css selectors work
			for-of to loop through the elements
		.getElementByTagName(name) - This does reflect changes wheras the above one just takes a snapshot
		.getElementById('name') - selects an object from the html (Can be used on html elements) (Most Performance)
			.classList
				.contains('name') - 
				.toggle('name') - toggles a class on or off
				.add('name') - adds a new class
				.remove('name') - removes a new class
				.replace('name', 'newname') - replace a given class
			.className = '' - write in a classname
			.style
				.css properties = '';
			.id - selects id
			.value - selects the value of the objec (ex input values)
			.max - selects the max of the object
			.min - selects the min of the object
			.textContent - selects the textcontent of the object (Useful to check for isNAN for example)
			.innerHTML - Changes html inside dom object -> It completely rerenders the html content
				`<div> <img src="${link}"/> </div>`
			.insertAdjacentHTML(position to add html, `htmlcontent`) - Adds content dynamically
				'beforebegin' - Before the element itself
				'afterbegin' - Just inside the given element before the first child
				'beforeend' - Just inside the given element after the last child
				'afterend' - After the element itself
			.createElement('li') - Creates an html tag element
				.appendChild(element) - appends the element to the Object
				.remove() - Removes the element from the page
				.append(element) - Adds it last in the selected tree 
				.prepend(element) - Adds it first in the selected tree
				.insertAdjacentElement - Same as adjacentHTML but for elements (SAFEST BEST WAY)
					'beforebegin' - Before the element itself
					'afterbegin' - Just inside the given element before the first child
					'beforeend' - Just inside the given element after the last child
					'afterend' - After the element itself
			.replaceWith(element) - Replace an element with a new element
			.cloneNode(true) - Clones an existing element, then you can append (element, clonedelement)
			.parentElement.removeChild(element) or .remove() - Removes the selected element
			onclick="invertColorsOfResults();" - Inside HTML add event listener, hard to use only if element gets rendered dynamically aka created by the dom.
			.addEventListener(event, functionToRunorAnonomousFunction) - Use
				
			.removeEventListener(copy the commands) - Removes an event listener good for clearing
				btn.replaceWith(samebtn.cloneNode(true)) - Workaround if you cannot use removeEventListener

	window - window related - The Real top most object, The Global storage for script, Root Entry Point
		documentSize attributes
			document.documentElement.clientHeight - height of browser window
			document.documentElement.clientWidth - width of browser window
		Dynamically Add and Run Scripts inside the javascript function (after the init) - For User Control
			document.createElement('script');
			.src = 'url';
			.defer = true;
			document.head.append(scriptName);
		Location
			location.host - returns the website name
			location.origin - Returns the url of the active window
			location.pathname - Returns the pathname / = root e.t.c.
			location.href = 'url' - navigates the user away to a new url
			location.assign = 'url' - same as href
			location.replace('url') - replaces the page, so cannot go back in browser
		.history
			.back - go back one page from where we came from
			.forward - go forward one page where you came back from
			.length - How many steps user has taken on this page
			.go(5) - Go back 5 steps in history
		navigator
			.clipboard - Access to the paste, copy feature on a browser
			.geolocation
				.getCurrentPosition((successdata) => {data}, (errordata) => {errdata}) - Get the current user location coordinates
					.coords.latitude
					.coords.longitude
	Events
		Events propogate up, they bubble up. Meaning two evenlisteners will trigger if btn is inside div. button triggers first then div.
		Inside the Html Code attribute (DON'T USE IT unless React. USE eventlistener or queryselector INSIDE JS DOCUMENT INSTEAD)
			onclick="" - click
			submit - only works on forms for example
			oncontextmenu - right click
			ondblclick - double click
			onchange - change
			ondrag - dragevents
			onblur - 
			mouseenter - Whenever mouse enters the object
			scroll - listens to the scroll everytime it accours (good for loading content for example)
			dragstart
			dragenter
			dragover
		Queryselector
			.onclick = functiontoexcecute; - click
			.click(). - Simulates a click on a given element.
		Or Just Use The Main AddEvenlistener function described above
		event object (used in the click,dbclick,drag is used, it returns that event) - generated and passed into the eventhandler
			You can actually do ALL THE DOM related functions here on the eventobject aswell, since it's LITERALLY A DOM OBJECT. This is quite fantastic when you think about it. The power of that. Ex appendChild works fine here.
			.preventDefault - Prevents the default behavior of a given html component
			.stopPropagation() - Prevents the propagation mentioned above, so the event stops in place
			.stopImmediatePropagation() - Useful if you have same eventlistener on same element
			.altKey - was alt key pressed
			.ctrlKey - was ctrl key pressed
			.button - which button was used
			.clientX - exact x coordinate where mouse pointer is on event
			.clientY - exact y coordinate where mouse pointer is on event
			.offsetX - exact x coordinate where mouse pointer is based on the object itself
			.offsetY - exact Y coordinate where mouse pointer is based on the object itself
			.target - which element caused this event (where you clicked on) for example - CRAZY USEFUL FOR EXAMPLE ADD EVENTLISTENER TO ENTIRE UL OBJECT AND CHECK FOR EVENT.TARGET to see which item in the list was pressed, one listener instead of many
				.name
				.value
				.disabled
				.closest('') - Selects the closest element up in the ansestor tree 
				.closest('li') - Selects the closest element up in the ansestor tree specified type
			.currentTarget - element that eventlistener is attatched to
			.screenX - 
			.screenY - 
			.relatedTarget - Which element mouse was at before going to the given object (does not work with fast mouse).click(). - Simulates a click on a given element.
				.closest() - works here aswell
			.dataTransfer
				.setData('type', what)
				.effectAllowed = 'what'
					none
					copy
					copyLink
					copyMove
					link
					linkMove
					move
					all
		Drag n Drop
			Make element draggable
				inside index html attributes - draggable="true"
				use evenlistener 'dragstart'
				event.dataTransfer.setData('text/plain', this.id)
				event.dataTransfer.effectAllowed = 'move'
			Create dropzone
				use evenlistener 'dragenter'
				and another one 'dragover'
				event.dataTransfer.types[0] === 'text/plain' - block unwanted data
				event.prevenDefault on both
				use eventlistener 'dragleave'
			Dropping element
				use eventlistener 'drop'
				event.dataTransfer.getData('text/plain')
				projects.find(p => p.id === prjId) - check if this id object already exists
				Do the transfer using something like the 
				Then remove class of droppable
				Then preventDefault again

	Useful ideas
		Modal UI/Modal.js
			have a class modal with show & hide function
			pass a contentId into the class
			Inside show - if('content' in document.createElement('template')) - Checks for internet explorer
			const modalContent = document.importNode(this.modalTemplateEl.content, true)
			use DOM functions to show modal



Relationships

Implement Repository Pattern - (The methods should happen behind the scenes)
	Contracts - (Represents the abstraction of a class)
			Interfaces. They are like the contracts
			IGenericRepository<T> where T : class
	Repository - (Represents the implementation of that class)

Concepts
	Block Scopes, local scope / global scope, different lexical enviroment
	Impure functions - Unpredictable outputs - Try and build pure functions
	Factory Functions (preconfigure a function using two nested functions) - Function inside of function. 
		If you call const = function(value) you refeer to the first input. If you then call const(value) then you create the second inputs of the nested functions
		function createTaxCalculator(tax){
			function calculateTax(amount){
				return amount * tax;
			}
			return calculateTax;
		}
		const calculatevat = createTaxCalculator(taxinput);
		calculatevat(amount);
	Closures - Every function in javascript is a closure, closures remember the surrounding variables
		variables used in them close around the pointer in memory, not the value itself, takes the latest value
	Recursion - Great for looping functions, OBS Crazy Useful when you don't know how much nesting/levels down you have
		It calls itself and then uses the return value of that function call until it gets an exit condition

		function powerOf(x, n){ - it multiplies itself n times, meaning it acts like a for loop
			return n === 1 ? x : x * powerOf(x, n - 1);
		}

		function printFriendNames(person){ - It just keeps going down the chain of data, deepest nesting level
			const collectedNames = [];

			if (!person.friends){ - Until there are no more friends
				return [];
			}

			for (const friend of person.friends){
				collectedNames.push(friend.name);
				collectedNames.push(   ...printFriendNames(friend)  );
			}

			return collectedNames;
		}
	Floating point ImPrecision .2 + .4 = 0.6000000001
		fix with .toFixed(2) - 2 Decimals
		Floating Points are simply imprecise in Javascript. OBS IMPORTANT to Understand this!
		You could use * 100

	Big numbers - Use the BigInt Type
		0951056956043n - Ends with n

Data Structures & Algorithms
	Big-O - Compare the different solutions (which solutions excecute how many times, time complexity time/items)
	0(1) Constant Time Complexity:
	0(log n) Logarithmic Time Complexity:
	0(n) Linear Time Complexity: T = n
	0(n log n) Linearithmic Time Complexity 
	0(n^2) Quadratic Time Complexity: T = n * n
	0(n^3) Cubic Time Complexity:
	0(2^n) Exponential Time Complexity: 
	0(n!) Factorial Time Complexity: 
	 

	We care about the Average case when thinking about Big-O

	Data structures time complexities. Unshift for example waay more expensive since it changes index of entire array
		Can javascript find the key/reference to an object immediately or does it need to look through?

	Common Algorithms Listed
		Sorting
			Sort Array numbers
			Sort Letters Alphabetically
		Even or odd
		Validations
			Check Values

HTTP Requests & Responses
	JSON, FormData, Binary e.t.c. Parsing

	HttpMethods
		GET, POST, DELETE

	XMLHttpRequest (Old Way)
		const xhr = new XMLHttpRequest();
			.open('method', 'url') - Define the request
				IF DELETE, use ${deleteId} in url
			.responseType = 'json' - Automatically parses the json xhr response object
			.onload = function() {handle the xhr.response object} - Does something with the response
			.send() - Send the request. 
				IF POST send(JSON.stringify(data))
		Handling server side error
			.onload = function() {
				if (xhr.status >= 200 && xhr.status < 300){
					resolve(xhr.response)
				}else{
					reject(new Error('something went wrong'));
				}
			}
		Handling Client side error
			xhr.onerror = function () {
				reject(new Error('Failed to send request!'))
			}
	Fetch API (New Way) - It uses promises on its own
		await fetch(url).then(response => {response.json()}) - GET data
			response.json() - Returns snapshot parsed json object
			response.text() - Returns plain text
			response.blob() - Returns file
			if (!response.ok){
				throw new Error('...');
			}
		await fetch(url, {configuration}).then(response => {response.json()})
			method: 'GET' 'POST' 'PUT' 'DELETE'
			body: JSON.stringify(data)
			headers: {
				'Content-Type': 'application/json' - Tells the server my request has json data

			}
			Characters to url friendly encoding
				encodeURI(url) - returns a Url friendly adress
	URL syntax
		? - followed by adding additional data in the request
		property=data - Name of data followed by the string of data inside it
		& - Use the AND sign to add more data after the first data (to add more)
		&lat=data&lng=data

	Error Handling (inside .then)
		.then(response => { 
			if (response.status is good){
				return response.json();
			}else {
				return response.json().then(errdata => { - So you return the body errdata and the response.json in one
					log errdata
					throw new Error('server side error')
				});
			}
		})
		.catch(error => {
			log error
			throw new Error('client side error')
		})
	Axios
		try { const response = await axios.get(....) } catch (err) { err}

		You can just use try catch easily with it. Really nice
		You also don't need to add headers. It adds this stuff automatically and does the converting JSON, formdata e.t.c.

		axios - Always returns promise which includes all the data, config, headers, it throws errors by itself
			.get(url) - 
			.post(url, dataToSend) - 
			.delete(url) - 

Browser Storage (Browser Storage) - stores temporary "convenience data"
	Ex. The personal shoppingcart, 
	Types of storage: 
		localStorage, sessisonStorage, 
			A javascript Object with key-value pairs, ex session id, analytics key, basic user-data e.t.c. Bad for complex data like a spreadsheet.
			This can very easily be manipulated by the user.
		localStorage
			.setItem('key', value) - Pass in any value you can convert to a string
			.removeItem('key') - Key is the unique identifier. Put the name in there
			.getItem('key') - Returns the string
			.length('key')
			.key('key')
			.clear('key')
			This way you can store more complex data.
				In order to store a javascript object in here use JSON.stringify(object)
				To access it just JSON.parse(localStorage.getItem('user'))
		sessionStorage
			...Same commands
			Sessionstorage lives as long as the browser window is open. Wheras localStorage is stored in the browser itself, even when you reopen it
		Cookies, 
			Simple key value storage, config options, user preferences or basic user data
			A bit clunky, but you Can set expiery dates. The cookies can be sent and read by the server. Which is an extra plus.
		document.cookie
			document.cookie = `name=${data}`
			document.cookie = `name=${JSON.stringify(dataObject)}`
			`data; max-age=*` - to set expiration date. Age * is equal to seconds
			`data; expires=*` - to use date
			You can use all string commands when using cookies
			To for example retrieve a single cookie
				const cookieData = document.cookie.split(';');
				const data = cookieData.map(i => {
					return i.trim(); - removes excess data
				});
				data[1].split('='[1]) - user value
		IndexedDB
			The most sophisticated client-based database. Manage complex data your web app needs.
			A bit clunky to use great for  complex non critical data and has good performance
		indexedDb
			const dbRequest = indexedDb.open('nameOfDb', 1) - it returns a dbrequest you can then use
			
			dbRequest.onupgradeneeded = function(event){
				const db = event.target.result; - Holds access to the database
				const objStore = db.createObjectStore('products', {keyPath: 'id'}); - stores db

				objStore.transaction.oncomplete = function(event) {
					const productStore = db.transaction('products', 'readwrite').objectStore('products');

					productStore.add({id: 'p1', title: 'product'}) - Any object can be added
				}
			}
			
			dbRequest.onerror = function(event){

			}
			
			dbRequest.onsuccess = function(event){ - Needed to work
				db = event.target.result;
			}

			To then access the db on outside functions
				const productStore = db.transaction('name', 'readwrite').objectStore('name')
					.add({object})
					.get('') - Gives request object you can then access using request.onsuccess = function handler (access it inside the request function using request.result)

JSON
	JSON.parse(data) - Converts json to javascript array

JSON Handling The Data
	Use a for-of loop

FormData - Great for sending and recieving a mix of files and text from/to API, much more structured than JSON and integrated with html forms
	new FormData()
		.append('name', content)
		new FormData(htmlform) - Passes html form to formdata, make sure it has a name

Error and Debugging
	MDN - This is where you see everything in javascript
	LOOK AT THE HINTS! PARAMETERS! 
	debugger; command
	console.log is your friend
	SCM view - Source Control view in Visual Studio Code

	Chrome Dev Tools
		Console - Very helpful for errors and warning messages
		Sources - Place Breakpoints
		Performance view in chrome perfect for evaluating what happens when loading the page. Press record and load the page.

	Install debugger for chrome in vscode - Helps connect to chrome
		start debugging


Other Built in fun
	navigator
		.geolocation
			.getCurrentPosition()

Generator & Iterable Objects
	yield - returns the current value of the loop and starts from the yield point again the next time the .next() is called (pauses the loop and then goes into it again on next excecution)

	Generator function* - Returns a next() method, object, and a done property, It's basically the way arrays work in javascript. What arrays and strings do internally and that you can manually build custom iterators, generators.

	const company = {
		employees: ['Max', 'Manu', 'Anna']
		getEmployee: function* employeeGenerator() {
			let currentEmployee = 0;
			while (currentEmployee < this.employees.length) {
				yield this.employees[currentEmployee];
				currentEmployee++;
			}
		}
	}

	- or replace getEmployee with [Symbol.iterator]: - Now you can use a for of loop
	- You get the value of the objects and an additional "done" property that becomes true when there are no values left to go through

	const it = company.getEmployee();
	console.log(it.next()) x5
	- This way you can write your own for of loopable objects with the help of iterators and generators, custom looping logic yield when to pause
	- You can even use spread operator with this [...company]

	Reflect API - To set Certain prototype methods, Reflect is better than the older Object API, It's better refined
		Reflect
			.defineProperty(Object, {})
			.deleteProperty(Object, {}) - Does not exist on Object API, returns true/false
			.getPrototypeOf(Object, {})
			.setPrototypeOf(Object, {})

	Proxy API VERY USEFUL! - Override/Tweak traps for object operations (excecute your own code when user does certain things)
		const courseHandler = {
			get(obj, propertyName) { - excecutes whenever someone tries to get a value
				return obj[propertyName]
			}
		}
		const pCourse = new Proxy(objectToProxy/Wrap, courseHandler)

		traps
			get(obj, propertyName){}
			set(obj, propertyName, newValue){}





Third Party Libaries
	Importing
		import the script before our script in html file
		cdn in src script tag

	It can slow down your application
	You can normally just import parts of libaries
	Work with well maintained libaries
	Don't add packages that might introduce security holes

	Lodash
	Jquery (Native dom is better nowadays)

Javascript Tooling
	Node.JS - needed in order for npm to work
	Project managed by Node Package - npm
		npm init + choose confuguration
		It creates a package.json file - Now you can install npm packages
		node_modules folder holds all dependencies of all packages installed
			recreate it using npm install
			you should always delete the folder when sharing your code to save space
		npm install --save-dev Name - Installs a package as a DEVELOPMENT PACKAGE, meaning NOT IN THE FINAL PRODUCTION


	Dev servers - good for hot reloading
		Webpack-dev-server
	Bundling tool - Combines multible files into bundled code
		Webpack
	Code Optimization Tool
		Webpack Optimizer Plugins
	Code Compilation Tool
		Babel
	Code Quality Checker
		ESLint
			Download inside vscode extension
			npm install --save-dev eslint
			ctrl shift p - Enable ESLint
			ctrl shift p - ESLint options
			Helps you with error detection

Security
	Potential Security Holes
		Your javascript code is read by EVERYONE
		If you have all user data from database for example
		any security stuff should never be on the client side
	Protecting Your Code
	Cross Site Scripting Attacks (XSS)
		malicious JS code gets injected and executed
		letting input change innerhtml of something for example, so he can add stuff, send to his malicious server
		He can steal confidential data e.t.c.
		Make sure we sanitice things away if you have a potential hole
		use sanitize.html, it should sanitize on server, be validated on the server
	Third party Libaries & XSS
		Make sure you add libaries that are secure 
	npm Packages
		The vulnerabilities might be a good indicator
	CSRF Attacks (Cross Site Request Forgery)
		People trick you using your cookies in the browser, ex version of payment page malicious
	CORS (Cross Origin Resource Sharing)	

Bundling - Webpack - Very Useful bundling solution
	npm install --save-dev webpack webpack-cli
	create config file webpack.config.js (next to package.json)
		const path = require('path');
		module.exports = {
			mode: 'development',
			entry: './src/app.js', - specifies where the entry file path is
			output: {
				filename: 'app.js', - The filename to be generated (our bundled code)
				path: path.resolve(__dirname, 'assets', 'scripts')
			}
		};
	inside package.json to use webpack
		"build": "webpack"

	then npm run build

	When webpack splits code bundles into two you need to fix the path in the config file.
		publicPath: 'assets/scripts/'
	Webpack development Server
		npm install --save-dev webpack-dev-server
		inside module.exports
			devServer: {
				contentBase './'
			}
		inside package.josn
			"build:dev": "webpack-dev-server"
	npm run build:dev - It recompiles every time you save something in the base document
	ctrl + c to quit
	Debugging
		devtool: 'cheap-module-evel-source-map' - Then when you reload you can see original files
	For Production - Add a new file called webpack.config.prod.js
		const path = require('path');
		module.exports = {
			mode: 'production',
			entry: './src/app.js', - specifies where the entry file path is
			output: {
				filename: 'app.js', - The filename to be generated (our bundled code)
				path: path.resolve(__dirname, 'assets', 'scripts')
			},
			devtool: 'cheap-source-map' 
		};
		inside package.json
			"build:prod": "webpack --config webpack.config.prod.js"
	Clear script folder with every new build
		npm install --save-dev clean-webpack-plugin
		const CleanPlugin = require('clean-webpack-plugin')
		inside module.exports
			filename: '[contenthash].js' - So browser doesn't read from cache
			plugins: [
				new CleanPlugin.CleanWebpackPlugin() - i know this from reading the docs
			]
		Add in poth the prod file and config.js file

	If you want to add external plugins with webpack - Then you have to import it
		import * as _ from 'lodash'; for example

Browser support
	MDN - caniuse.com (includes market shares!) - google - ES6/JS Compat Table
	Analyse the market. Who will be your users? tech-savvy? older? Internal company tool?

	Workaround so that your application does not crash on a browser that does not support a given feature
		if (navigator.clipboard){ - If its not undefined, then run the given code.

		}else{
			...feature not availible or some fallback code to work around the feature.
		}
	Use polyfills - install it so you are able to use promises, in older browsers for example

	Use Transpilation - let, const, async/ await, so older versions of browsers can use these features
	Babel helps convert your code to older browser code (used with webpack)
		npm install -D babel-loader @babel/core @babel/preset-env webpack
		add the module rules into webpack.config.js
		Inside presets env pass, you configure the browser list in the package.json
			"browserlist": "> 0.2%, not dead", - you specify here the range of browsers and babel does the rest
	Add polyfills
		install core-js
		You also need regenerator runtime installed
		inside babel presets: [
			['@babel/preset-env', {useBuiltIns: 'usage', corejs: {version: 3}}]
		]
	<noscript> Please enable javascript to use this webpage </noscript>


APIs
	Google maps
		const map = new google.maps.Map(domelementtorendermapon, {center: coordinates,
		zoom: 16})

		new google.maps.Marker({
			position: coordinates,
			map: map,
		});
	Google GeoCoding - Returns adress long lat coordinates

Find Out
	How to go diagonally through a matrix?

Performance Optimization
	smooth, freezes, lags? visual lag? memory leaks?
	Startup time (webpack helps here)
		Bundle / Script Size - delays initial parsing / execution
		Number of Http Roundtrips - Non bundled code third party libaries delay initial parsing / execution
	Runtime performance
		Optimize Code Execution, DOM Access - To avoid unnecessary code execution, DOM repaints (dom is really expensive)
		Memory Leaks - Avoid them, they can crash application or significantly slow it down
		Find Code Alternatives with better performance - Important for "high frequency" code parts
		Micro Optimizations - e.g certaint data structures for frequent access / changes (less important)
	Measuring performance - (you always measure the production code)
		performance.now() - Add to code during testing to check excecution time
			const startTime = performance.now();
			...Code To Test
			const endTime = performance.now();
			console.log(endTime - startTime); - Gives you the time difference (use jsperf to get more accurate results)
		Browser DevTools - To detect unnecessary code excecutions, http requests and measure excecution/memory leaks
			performance view snapshot - Here you can track the time certaint actions took to look into potential fix
			Memory tab - Heap snapshot, comparison, you can see which items were added to memory and which were not. This way you can discover memory leaks
			Audits - Gives your page insight into what needs to be fixed (performance test)
		jsperf.com - Compare alternative code snippets to measure performance
		webpagetest.com - Test entire live web page
	Fantastic Optimization tips
		Splitting your code into optimized components, ex Products, deleteproduct function, addproduct, render function into seperate modules. Saves alot since they get imported dynamically as they get used
		Check for what things are rerendered. Only the specific items being changed should be rerendered.
		Most of the memory leaks will happen due to references to objects still being there despite deletion for example

Automated Testing
	Unit Tests - Fully Isolated (testing a single function) - Write 1000s of these!
	Integration Tests - With Dependencies (testing functions that calls functions) - Write a good couple of these!
	End-to-End E2E Tests - Full flow, ex validating the DOM after a click - Write a few of these!

	Jest.js - For testing input/output cases if passed or not
		Concept
			Always use exports.* to export things aka the node.js way
		Installation
			npm install --save-dev jest
			new file NameOfJsfiletoTest.test.js
			import function to test const { } = require();
			inside package.json scripts->test replace with jest
				jest --watch - to make jest run everytime you save the file
			npm test
			Helps alot with how the function outputs work
		Commands
			- The test + expect checks for inputs and corresponding outputs
			test('define what you are testing', () => {testingCode...}) - 
			expect() - 
				.toBe('output') - Define what to expect
		Mocks
			You can add a __mocks__ folder, add http requests in it and then 
			jest.mock('./fileToMock') - Same name of file needs to be found in the __mocks__ folder
	Puppeteer - Robot check for full custom browser flow
		Installation
			npm install --save-dev puppeteer
			import using const { } = require();
		Commands
			- Inside test callback function
				const browser = await puppeteer.launch({
					headless: false,
					slowMo: 80,
					args: ['--window-size=1920,1080']
				})
				const page = await browser.newPage();
				await page.goto('URL to be loaded');
			- Then instruct the browser window what to do page.
				.click('Object')
				.type('Object', 'Value')
			- Check for certain values
				.$eval('Object', value => value.textContent) - for example
				.toBe('Value')

Frameworks
	Front-End Frameworks
		Angular, - Uses Typescript, Very popular contains loads of features
		React, - Uses enhanced JSX, Also very popular, huge echosystem, need to combine with other libaries
			You manage State, it automatically changes state, UI Components
		Vue.js, - Uses regular Javascript, Easy to learn and contains all important features
		Typescript, - 
	Back-End Frameworks


Deploying
	Only HTML + CSS + JS (static host)
	Single-Page-Applications (SPAs, Only one HTML page being served, JS Rerenders dynamically)
	Dynamic / Server Side Application Node.js (dynamic host) - html content served dynamically on the server

	Take the webpack Optimized output and 

	Hosting Options: Firebase, AWS, Beanstalk, Heroku, MS Azure, 

Programming Paradigms
	The way you write your code
	Object-oriented - Logical Entities - Organize code in objects/classes, In real world terms and how you organize it
	Procedural - "Top to bottom" code execution
	Functional - Organize Code in (pure) functions with clearly defined tasks - Pass data around via parameters
		All functions should be pure, all data is recieved as parameters
		I Should do this most of the time! Inside .NET and Javascript. And then use modular approach aswell with React.js For example. Object oriented and Functional Programming are quite close together.



Typescript
	Installation
		npm install -g typescript
		use .ts files to write typescript
		Compile .ts to js
			tsc *.ts -w file
		Configure Typescript Compiler
			tsc --init
			Run tsc or tsc -w - Now it compiles all typescript files
			Look at tsconfig.json - To configure compiler options
				strict: '' - Some things 

	Types - Typescript Infers certain types, it's very clever about this
		number
		string
		void - Null
		undefined 
		HTMLInputElement
		any

		Generic Types
			Array<any>
			Array<number> - array of numbers
			Array<string> - array of strings 
			Array<{a: number}> - array of objects

			[] - array
			number[] - array of numbers
			string[] - array of strings
			{a: number}[] - array of objects

			Promise

			<T> / T - Generic Type

		Custom Types
			enum - Create your own Enum
				enum Name { CONSOLE, ALERT }
			Custom Type - Create your own Type
				type CustomType = {...}
					'console' | 'alert';

		Typescript Interfaces / contracts -> Blueprint for objects & classes

		_privateNamingConvention


	Syntax
		! - Make nullable / ignore nullable
		
		functions
			a: type
			function(a: type, b: type)
			function(a: type, b: type): returnType
			function(a: 'console' | 'alert') - Literal types/union type, or just use custom type/enum
		
		Cast / Override type
			a as type
			<type>a
			+string - string to number

		Objects
			const Object: {value: type} = {...}

		Arrays
			const Array: {value: type}[] = [] - Array can only have an object with a given value type
			const Array: {print: (a: type, b: type) => ReturnType}[] - Array can only have an object with a given function 

		Classes
			Classes are the same - class User {}
			Constructors
				constructor(private a: type, public b: type) {} - same as writing this.a = a; inside constructor
			Classes with inheritance are the same - class Admin extends User {}
			Super works the same - super(name, age)

		Interfaces / contracts (Typescript Exclusive)
			interface Name {
				id: number,
				print(): void,
			}

			You then just use it as a type

			class User implements Inteface - You now get forced to implement the types from the interface IN the given class. Crazy useful Now we getting close to C# Territory but using Javascript!! How cool isn't that!

		Generic Functions
			Name function<T>(val: T)
			Name<string>('hello')

		Generic Classes



Node.js
	Installation
		Look in CommandLine, GitBash and Git.txt
		node file.ext - Runs the file using node 
	Concepts
		Node has modules, with certain features, you need to import those modules to use them
	Syntax
		import export
			const moduleName = require('moduleName');
			module.exports = function;
	Commands
		fs - Filesystem Module 
			.WriteFile('file.ext', 'data', {other args}, err => {}) - Write a file to system
			.readFile('file.ext', (err, data) => {}) - Get data, use toString to convert buffer to string
		http - http Module
			.createServer((request, response) => {}.listen()) - request function triggers for every request/response
				response
					.setHeader('Content-Type', 'text/html') - Important to set the header of data being sent
						'text/html'
						'text/plain'
					.write('<form></form>') - Writes a line, you can embed html in this response
					.end() - We are done with the response
				request
					let body = [];
					.on('data', (chunk) => {})
						body.push(chunk)
					.on('end', () => {})
						body = Buffer.concat(body).toString();

			.listen(3000) - Use on createServer to actually start the server on port


Express.js
	Concepts
		Express.js It's a middleware driven framework (funneling incoming request) function that can get a request and do something with it
	Installation
		npm install express --save
		const express = require('express');
		const app = express(); - It calls createserver for us
	Syntax
		Middleware
			.app
	Commands
		app
			.listen(3000) - Use on createServer to actually start the server on port
			.use((req, res, next) => {}) - Create multible of these middlewares
				.setHeader('Content-Type', 'text/html') - Important to set the header of data being sent
						'text/html'
						'text/plain'
				.send('') - Send back string
				.next(); - Sends the request over to the next middleware below
				req
					.body.value - Grabs the request body values
				res
					.render('viewnameToRender', {data name: 'tom', description: ''});
					.json({message: ''}) - Return json message
					.status(404) - Return status code 400 404 200
		Router
			routes folder put in the route
			express.Router();
				.post('url', (req, res, next) => {})
				.get('url', (req, res, next) => {})
			locationroutes = require('./routes/location') - To import router file
				app.use(locationroutes);
	Setup CORS
		Create a new middleware (remember next() after middleware)
			res.setHeader('Access-Control-Allow-Origin', '*') - Any server request
			res.setHeader('Access-Control-Allow-Methods', 'POST, GET, OPTIONS') - Any type of requests
			res.setHeader('Access-Control-Allow-Headers', 'Content-Type')
	Connect To Database
		MongoDbDriver - npm install mongodb --save + import mongoClient
		Just Read the documentation... when you wanna use it

Packages
	body-parser
		Installation
			npm install body-parser --save
			import body-parser
		Usage
			app.use(bodyParser.urlencoded({extended: false}))
		Commands
			bodyParser
				.urlencoded({extended: false}) - parses form data, extended false how its parsed
				.json() - parses json data
	ejs
		Installation
			npm install --save ejs
			app.set('view engine', 'ejs')
			app.set('views', 'folderNameOfViews')
		Inside Views folder
			index.ejs - Here you write HTML Code
			Dynamic content
				<%= user %>
		Inside Node Middleware
			res.render('viewnameToRender', {data name: 'tom', description: ''});


	Deployment
		app.listen(process.env.PORT || 3000);


React.js
	Installation
		npx create-react-app name
		npm install (installing all node.js modules dependencies) 200mb
		Commands
			npm start
			npm run build
			npm install package-name

	Deploying in React.js
		in .env. Change react_app_base_url to the webapi online
		npm run build - Runs a production build for us
		inside "build" folder you should have the build files ready
		you put them inside wwwroot folder inside your web provider
		web.config needs to be dropped aswell
		
	Folder structure
		public
			index.html - The entrypoint of the react application
		src
			Index.js - First code file
			App.js - Main Code
			index.css - Main css
		utils
			all js formula files and stuff
		components
			All components n stuff
			Booking
			Main
		img
			All image content

	Imports & Exports
		import Name from 'Location'
		export default Function-name
		go back ../
		in same folder ./

	React / ReactDOM
		Create component
			<Component /> - Outside Component
			function Component(props) { return () } - Inside component
			you must always return a container cheat with - <> </>
		Styling
			className=''
			Wrapper styling Component. Card.js with a single div with css
				to able to wrap <*> .. </*> use {props.children} - inside component
				const classes = 'card ' + props.className;
			Use dynamic css classes (modules)
				import classes from 'ErrorModal.module.css'; - inside component
				then assign the class with className={classes.btnclassName} - inside component
		states - Can be Api, Boolean, Object based
			Creating
				const [the value, setting the value] = useState({})
				const [bookings, setBookings] = useState({})
				const [loading, setLoading] = useState(false)
				const [bookingFormState, setBookingFormState] = useState({
					name: '',
					description: '',
					Timeslot: {
						id: '',
						startTime: ''
					}
				})
			Updating state
				pass another function through inside the handler and use prevstate
				bookingstateHandler = (event) =>{
					setBookingFormState((prevState) => {
						return {...prevState, name: event.target.value}
					})
				}
				Use spread operator to set the rest of the state values without specifying all the individual ones
						setExpenses((prevExpenses) => {
							return [expense.name, prevExpenses...]
						})
						instead of:
						setExpenses([expense.name, ...Expenses])
		UseEffect
		Lifting state up
			Storing state up one component so two components can communicate with each other

		EventListeners
			use ..Handler as naming schemes for the functions when handling events
			onClick={call function}
			onChange={call function}
			event object - You always get the event object by default in jsx
				.target.value - Holds the value of the current value of the object
		Data
			{data.name}

			Pass props to components
				startTime={bookingformstate.startTime} - Outside component
				function(props) <h1>{props.startTime}</h1> - Inside component

			Pass props from component to lower level component
				startTime={props.startTime} - Outside component
				{props.startTime} - Inside Component

			Pass functions to components
				function={functioninsidecomponent} - Outside component
				{() => props.functioninsidecomponent} - Call function fr inside component

		Two way Databinding
			set value of state inside of function and inside the component prop

		Forms
			onSubmit={}
			prevent reloading the page - e.preventDefault()
			with labels use htmlFor="username"  if id is username on input below 

		If else and conditionals
			return (condition) ? ( truecontent ) : falsecontent ;
			{condition && truecontent}

		Rendering Lists Dynamically
			map = map every item into a certain thing
			{item.map((expense) => <ExpanseItem title={expanse.title}/>)}
			{items.map({ startTime, endTime}) to map individual things inside an existing object

		Concept of mapping more complex and nested json data
			Inside .net make sure Microsoft.AspNetCore.Mvc.NewtonsoftJson is installed and setup

			Map first data NetProjects.map(NetProject => ())
			To nest the data inside just make a second map function
			NetProject.nameofnextobjectarray.map((breakdownsection) => ())

			Then do exactly the same for 3 levels down. This way it also dynamically renders without having to compare ids or some stupid shit i had to do inside of MVCrap

		The Special Key prop and id, it helps react identify the unique items
			Every list item should have a unique id, so you add a key
				key={expanse.id}
			if no id then you could use items.map((expense, index) => ) - BUT DISCURAGED

		Error state
			useState() - Inside function
			then setError {title: 'invalid age', message: ''}
			error && ..render


	JSX
		Spread Operator ...
			...object - takes all the key value pairs off of that object 
			...array - Takes all the key value pairs off of that array

		Compressing const declarations
			const name = e.target.name
			const value = e.target.value
			Is the same as:
			const {name, value} = e.target;

		const Object = {day: 6, humidity: humid}
		const Array = ["Monday", "Tuesday", "Wednesday"]

		constructors
			new Date()

		function Function(){} exactly the same as: const function Function = () => {}

		Modifiers
			.toISOString()
			.slice(0,5)
			.toLocaleString('', {})
			.getFullYear()
			.trim() - removes any excess whitespace
			.length - checks the length of a word (length === 0 is an empty string)
			.Math.Random().toString() - Pseudo Unique Id

		for (const expense for props.expenses) {}

	Typescript (adds classes and types to javascript)
		Installation
			npm init -y 
			npm install typescript
			To run compiler
				npx tsc
		Setting up a react project with typescript
			npx create-react-app my-app --template typescript
			.tsx files

		Primitives
			number, string, boolean, arrays, objects

		Declaration - Typescript automatically assigns a type to an object, don't state the type. Just use the type inference ex let age = 5.5; or let hobbies = 'hello';
			let age: number = 5.5;
			let hobbies: string[];
			let person: {	Object
				name: string;
				age: number;
				single: boolean;
			};
			let people: {   Array of objects
				name: string;
				age: number;
				single: boolean;
			}[];

		Union Type - Variable where more than one type can be allowed
			let course: string[] | number | boolean = 'course';

		Unique type definition
			type Person = {
				name: string;
				age: number;
			}

		functions - Typescript also uses types for return
			function add(a: number, b: string){return a + b;}

		Special return type Void (Returns nothing)
			function print(value: any){console.log(value) }

		Generics functions - the array t is the same as the value t type
			insertAtBeginning<T>(array: T[], value: T){

			}

		Inside Component in react
			const name: React.FC<{Declare items types in here}> = (props) => {}
			item?: - is nullable
			! - Type can't be null, the connection will always be established

		Model Files - Defining a custom c# class like object
			.ts extension!
			interface, type, class Name{ }

			Inside TS file
			class Todo {
			    id: string;
			    text: string;

			    constructor(todotext: string) {
			        this.text = todotext;
			        this.id = new Date().toISOString();
			    }
			}
			Inside App.tsx
			const todos =  [
			    new Todo('Learn React'),
			    new Todo('Learn Typescript')
			  ];

	export default Todo




	Genious code snippets
		const handleBookViewChange = (e) => {
		    const {name, value} = e.target;
		    
		    setbookview((prev) => {
		      return {...prev, [name]: value}
		    })
		  }

		bookingFormState.timeSlotId = 1;

		booker ? availability_icon is green : availability_icon is red

		props.dataPoints.map(dataPoint => )


		src={flagimage[language_item]} 


	Finding & Fixing Errors
		

	Github Actions
		git init - Initialize a local Git repository 
		git clone ssh://git@github.com/[username]/[repository-name].git - Create a local copy of a remote repository
		git add [file-name.txt] - Add a file to the staging area
		git add -A - Add all new and changed files to the staging area
		git commit -m "[commit message]" - Commit changes

		git branch - List branches (the asterisk denotes the current branch)
		git branch -a - 	List all branches (local and remote)

		git push origin [branch name] - Push a branch to your remote repository
		git push -u origin [branch name] - 	Push changes to remote repository (and remember the branch)

		git branch [branch name] - 	Create a new branch
		git checkout [branch name] - Switch to a branch
		git merge [branch name] - 	Merge a branch into the active branch
		git merge [source branch] [target branch] - Merge a branch into a target branch

	Make a accordion
		


	injenious react code

	<h1>Hantera Bokningar {title} {bookingFormState.name} {bookingFormState.timeSlotId} {bookingFormState.description}</h1>
	<input value={title} onChange={(e) => setTitle(e.target.value)}></input>


	https://www.youtube.com/watch?v=-KBS93RlUCY&ab_channel=CodeBlessYou


	injenious react code

	<h1>Hantera Bokningar {title} {bookingFormState.name} {bookingFormState.timeSlotId} {bookingFormState.description}</h1>
	<input value={title} onChange={(e) => setTitle(e.target.value)}></input>


	https://www.youtube.com/watch?v=-KBS93RlUCY&ab_channel=CodeBlessYou




	React
		Basics
			Tips
			Naming Switches as Handler functions (eventhandlers) in the name is a good practice.

			Props and State - Is what react looks at to change the existing DOM

			Have way more components instead of different states, it becomes way more clear - Way less spagetti code

			Always give custom components an Uppercase letter, to seperate from html lowercase

		Install React app
			npm install create-react-app -g
			create-react-app nameofproject - creates a react app
				--scipts-version 1.1.5 - To get same folder structure
			npm start - start your project
		Creating components
			import React from 'react'; - Always
			define a function as const and return () 
			export default functionname; - Done. 
		HTML Inside React
			Commands
				className="" - same as declaring a class
				onClick={} - when you click on the object excecute following code
				onChange={} - Refeers to the input value on change
				value={} - Sets the value of the given html element
		Run js code inside html element
			{...} - wrap your js code in braces

	Updating State of DOM
		Sets the *Default State of the DOM
			state = {...write objects in here} - special tag in App Component right before render() function
			You can have multible object in a state

			To then access the state property classes just use this.state.classes[]
		Change the state
			this.setState({                - Changes the state of the DOM - very usefull
				Nameofarrayclass: [
					{What to change}
				]
			})
		Write functions
			Right before render() function aswell functionname = () =>

			this.functionname refeers to the function - DON'T ADD (). This will excecute it on application start


	Commands - Passing data back n forth
		Input data into component
			<Component customproperty="inputInfoHere..">

			Import props inside function of component
			use {props.customproperty}

		Input data between component tags
			<Component>some text<Component/>

			use special name of props.children, to access the value between the component tags

		Excecute inside main from component
			ex onClick={props.functionname} - refeers to the function refeered in main

			<component name={this.functionName} - Passes Reference to function into component so you can use it in the component itself

		Input data from component tag to function
			.bind(this, 'Max!') - Pass an argument into a function, remember to import the argument into the function

		Extract specific data of item in question that component did some action on.
			Inside component just refeer to the function refeered in main action={props.functionname}

			Pass the reference function into the component for use in the component
			<component name={this.functionName}

			Now by default component action always sends a "event" with many different values. You can name the property in the function import anything you want but the property being sent can be used to link / extract different values of the given object
			Importing: function = (event)
				.target - where they clicked originally
				.currentTarget - the parent of where they clicked
			Event Commands
				event.target.value - the current value of target that sent the event 
				event.target.tagname

		Switch between two false / true values
			define a value and give it a boolean, then make a const refeering to that value ex conts
			If you then set the value to !const - Then it means apply the value that is NOT const. So the only other value becomes true in this case. So it applies true. Good way of simplifying the code and not using spagetti if else code
				const doesShow = the state of the card;
				this.setState({thestateofthecard: !doesShow}) - It sets it to the opposite of what it is

		Render dynamic content conditionally
			Use a state object that you can use as switch, false / true

			Have something that triggers a function that changes this switch

			Before return and after render() 
			let variable - Define a variable. (you can give it a default value here if needed, ex null or something else)
			use a simple if statement to check for boolean condition in this.state.* statement is true or false
			Now simply change the content of variable based on if statement
			if (*) { 	persons = ( <h1>Hello<h1/> ); - for example
			}
			you can totally use else, if else here if you want aswell. The point is stuff renders dynamically based on condition. Which is great

			{persons} - inside main to refeer to it

		Render dynamic content conditionally (The bad method)
			Inside the main return
			{ this.state.showpersons ?   - ? means if true
			....
			: null						 - : means else
			}
		Render items in list format
			this.state.arrayname.map((Functioninputfromarray,index) => { - Index is the location of the arrayitem
				return <Namecard />
			})

			
			<component name={this.functionName} - You refeer to the array contents this way (same way as default but instead of 
				{this.state.Arrayname[0].age}
			You write
				{Functioninputfromarray.age} - instead. It renders as many objects as long as the array is
											   If you give no info in two areas it will still render however.

		Key property
			You should always apply a key property in components when rendering using a list
			key{person.id}


Web Components
	Syntax
		Basic Syntax
			class Name extends HTMLElement {...} - Creates an HTMLElement
			Constructor() - basic initializations - You have to call super() Before any commands
			connectedCallback() - DOM Initializations, where you can access dom, or start adding content
			disconnectedCallback() - Cleanup work, whenever Elements are detatched from the dom
			attributeChangeCallback() - Update Data + DOM when attributes that are passed to the components are being changed

			customElements.define('uc-tag', Class) - Creates the html tag from class. You have to have a dash in the name
		
			<uc-tag> </uc-tag> - Creates the html tag
	Commands (inside class) this.
		All the html Commands
		.appendChild()
		.createElement('');