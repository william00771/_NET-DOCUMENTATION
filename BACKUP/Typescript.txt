Typescript - A superset of javascript, includes something but extends it. It compiles down to javascript.
	You are expected to define your own types.

	Installation & Setup
		npm init -y
		npm install typescript --save-dev
		touch tsconfig.json
		npm install @tsconfig/recommended --save-dev
		npx tsc - To build

		-D same as savedev

		tsconfig
			describes what to compile and what not to

		typescript doesnt know what node is, so we have to add the node types
			scripts: "build:watch": "tsc -w"

		npm install ts-node -D - Wrapper around node

	Common Noob mistakes
		Don't overuse the Any* type!
		Use Union Types!
		Overusing types, we don't have to say number everywhere. Typescript is smart enough. Think C#.



	Declarations
	CALLBACKS
		You can define a callback first to then use it
			const delayCallback = (cb: () => void) => setTimeout(cb, 100);
			delayCallback(() => {}) - everything wrapped inside gets affected by delay
		You can create functions that return callbacks - They don't explicitly return instead calls the callback with error object or result object
			const addCallback = (number1: number, number2: number, cb: ErrorOrResultCallback) => {
		        cb(error); OR
		        cb(null, roundedResult);
			in this case a cb callback that returns error or result
		const roundToIntegerCallback = (numberToRound: number, callback: ErrorOrResultCallback) => {
			  return Number.isNaN(numberToRound)
			    ? callback(new Error('Rounding failed'))
			    : callback(null, Math.round(numberToRound));
			};
		roundToIntegerCallback(divideResult, (error, roundedResult) => {
			Here the input is divideResult, after the comma the actual results from the roundTointeger get passed in. It can be either an error or roundedresult. Then we can use this cb(error) or roundedresult depending on the output result of roundIntegerCallback

	PROMISES - Perfect example
		const addPromise = (number1: number, number2: number): Promise<number> => {
			  return new Promise<number>((resolve, reject) => {
			    if(number1 && number2){
			      delayPromise()
			        .then(() => {
			          return number1 + number2;
			        })
			        .then((addResult) => {
			          return roundToIntegerPromise(addResult)
			        })
			        .then((roundedResult) => {
			          resolve(roundedResult);
			        });
			    }
			    else{
			      reject(new Error('failed operation'));
			    }
			  });
			}
	ASYNC AWAIT - Perfect async await example
		const divideAwait = async (number1: number, number2: number) => {
		  await delayPromise();
		  if (number2 === 0){ 
		    throw new Error("Division with zero not allowed"); 
		  }
		  const divResult = await roundToIntegerPromise(number1 / number2);
		  return divResult;
		};
		Functions
			function greet(value: string){} - string as input
			function greet(value: string) : Type {} - Function returns Type 
			function greet(params: {first: number; second: number}){p.first p.second} - string as input
			function greet(params: CustomType){p.first p.second} - string as input'

			function greet(params: Custom) : void

			function getDefaultUserAndPosts = (): User & { posts: Post[] } => { - Returns User with 
				return {
					id: "1",
					firstName: "Matt"
					posts: [
						{
							id: "1",
							title: "post1"
						},
						...
					]
				}
			}
			- You return Type of two combined types


			c?: number - Optional parameter
			last: string | undefined - You can pass in string or undefined.
			lastName: string = "Hammarberg" - Default parameter
		Types
			number (all float), boolean, string
			number[], string[], Array<number>

			type CustomType = {
				first: number;
				second: number;
			}

			READONLY
			type point = {
				readonly x: number;
				readonly y: number;
			}

			const post: Post[];

			const Name: Type | null = ... - It can be two types, type of Type and type of null

			const Name = (amount: number | { amount: number }) - Can either contain a number, or an object with number inside it

			const 

			You can return from Types depending on how we declare/use them
				const Name = (amount: number | { amount: number }) => {
					if(typeof amount === "number"){
						return amount;
					}
					return amount.amount;
				}

			type DefaultUserAndPosts =  User & { posts: Post[] & {age: number}{

			}
			- An brand new type of three combined types being User, object with posts inside, and object with age

			Omit
				type MyType = Omit<user, "id"> - Excludes the Id
				type MyType = Omit<User, "firstName" | "lastName"> - Exclude firstname or lastname 

			declare a function type - GOOD PRACTICE, when you want to pass functions into other functions
				type FocusListener = (isFocused: boolean) => void; - Returns void. So you don't need to return anything from the function

				const myFocuslistener: FocusLister = () => {

				}

				const myFocusListener = (IsFocused: boolean): void => {

				}


		Collections
			const post: Array<Post>; - array of type post
			set() - aka hashset
			Set<string> - New set of type string
			Map<string> - New map of type string
			Record<string, string> = {} - Aka Dictionary, can contain any sort of keys that we want

			const input: Array<string> = ["2", "3"]

		Interfaces
			interface CustomInterface {
				first: number;
				second: number;
			}

		Function Types - Use funcion as 
			type MathOperation = (x: number) => number;

			function calc(args: number[], fn: MathOperation)

		Contracts
			const defaultUser: Admin{} - defaultUser is a contract of admin, you also get autocomplete

		Type Constraints (Union Type) (aka kind of like enums, you have to set it to a specified predefined value)
			role: 'admin' | 'user' | 'super-admin'; - You can even use types here type SuperAdmin. 
			enum Direction {
			  Up = 1,
			  Down,
			}

		Working with array types
			const post: Post[] - [{id: number, }]

		Inheritance
			interface User extends Person, Id {}


		event
			event loop, calling functions is not something that blocks the event loop


		Any type 
			IF you truly don't know what the response data is going to look like, for example after fetch request
				You can return
				: Promise<LukeSkywalker>
				const data as LukeSkyWalker; - It casts the fetch const data to LukeSkywalker
			any type - you should create your own type for this
		
	Error Handling
		try{
			...
		} catch(e){
			return (e as Error).message;
		}

		try{
			...
		} catch(e){
			if(e instanceof Error){ - Check if its a typeof
				return e.messagE;
			}
		}

		instanceof TypeError, InstanceError, Error

		throw new Error('message');

	All about functions



		

	command.then((val) => do something with it) - Same as await

	value: type - Reversed way of c# also remember the :

	types
		string
		Error
		HTMLElement

	export default class CustomRetrypolicy implements signalR.Iretrypolicy - Same as class : Hub, every class is js public

	new CustomRetrypolicy() - Instantiate class


	Jest - aka xunit for javascript
		npm i -D jest ts-jest @types/jest
		npx ts-jest config:init

		It == should

		describe('it is alive', () => {
			it('get greeting', () => {
				const result = greet('')

				expect(result).toEqual("hello Salties")
			})
		})

		Run tests
			npm test
			npm run test:watch


Node - A JS Runtime enviroment. Backend. npm is a project manager.
	We can do async programming even thought node.js is single threaded
	It is also a package echosystem with npm

	Importing & Exporting
		import {destructuredthing} from './greeter.js';
		import * as greeter from './greeter.js'

		export const FunctionName = () => {}
		export default FunctionName;
		<script type="module" src="greeter.js">  - Module always loads after html loads

		.mjs - second way of exporting, non ecmascript modules
		.cjs - module.exports, new way of exporting, ecmascript modules


ES Lint
	setup
		create new file named .eslintrc.js

		module.exports = {
			env: true,
			jest: true,
		},
		extends: ['plugin:@typescript-eslint/recommended', 'eslint:recommended'], - Should be in reversed order
		parser: '@typescript-eslint/parser',
		plugins: ['@typescript-eslint'],
		root: true,

		Inside json
			"scripts": {
				"lint": "eslint ./src/**/*.ts"
			}

		error lens
			auto fix with cmd + . k

All about configs bby
	ES Lint - 
		.prettierrc.js
	Prettier - 
		.eslintrc.js
	Tsconfig - Controls behavior of typescript compiler
		.tsconfig.json
			compilerOptions
				module
				esModuleInterop
				target - target flavour of javascript to compile to
					es6
				moduleResolution
				sourceMap
				outDir - the out directory when it compiles
			lib - 
			include - what directories to include
				["**/*"]
	Vite config - Bundles everything together
		vite.config.js
			root - 
				'app'
			build {}
				outDir - Specify the out directory for npm build
				emptyOutDir - 
				assetDir - 
			server
				port - specify port of npm run dev
	package json - Where you configure all the packages and npm commands
		package.json 
			devjson
	tailwind config
		tailwind.config.js
	postcss
		postcss.config.js
	playwright - E2E Testing
		playwright.config.js



		
