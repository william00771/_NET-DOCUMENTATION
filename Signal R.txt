signal R - Uses websockets
	The Three transport types used by signalR
		Websockets - 
			Always available connection
			open connection between client and server
			Socket pools can be exhausted when multible users and tabs are connected
		Server-Sent Events - 
			Good fallback for when websockets do not work
			Client cannot use EventSource to send messages
		Long Pooling - 
			It works on ALL browsers
			Constant connection/disconnection cyclas are not ideal. Slower. You are constantly killing and starting new connections.
Common
	Connection Identifiers
		ConnectionId - ID for this particular connection for every client connection, it refreshes on page refresh
		UserIdentifier - with asp.net identity for example
		User - with asp.net identity
		Items - store metadata for an individual connection context
		ConnectionAborted - cancellation token, if originator cancels the request

	Returning Data - BE AWARE of when working with LARGE AMOUNT OF DATA JSON conversion takes time!

	Real Production
		Connection Pool is always a problem you run into. So Azure Service Helps you so much
		blinks red in traumatic event. Seriously incredible app

	The idea of streaming service, you need to make sure you are beginning the stream at the BEGINNING of the file, moving forward

	Azure Signal R Service - Instead of signal R directly through servers, the signalR service takes alot of the load

Setup
	Client
		Setup
			Microsoft.AspNetCore.SignalR.Client
			import * as signalR from "@microsoft/signalr";

			let connection = new signalR.HubConnectionBuilder()
			    .withUrl("/hubs/view")
			    .build();

			    setup transport types
			    	.withUrl("/hubs/view", { 
			        transport: signalR.HttpTransportType.WebSockets | 
			        signalR.HttpTransportType.ServerSentEvents})

			Client Listener
				connection.On<string>("changeBackground", (color) => {
					set ... to color...
				})

			Send from client to server
				await connection.SendAsync("ChangeBackground", "red")

			await connection.startAsync().then(startSuccess, startFail);

			await connection.StopAsync(); - If you want to stop the thang

		Call hub methods from client
			send from client to hub
				connection.invoke("hubMethodName", param1, param2);

				.invoke("hubMethod", param1, param2) - Send to hub (primary way)
					.then((val) => ...)

				.send("hubMethod", param1, param2) - Send to hub
					.then((val) => ...)

		Add event listeners in client
			connection.on("hubMethod", (val) => ...) - Listens to server events

			connection.off("hubMethod") - Turns off listener for event

	Server
		Setup
			services.AddSignalR();
			Create new hub - Hub/ChatHub,ViewHub and inherit from hub
			Register Hubs
				app.UseEndpoints(configure => {
	                configure.MapHub<ViewHub>("/hubs/view");
	                configure.MapHub<ChatHub>("/hubs/chat");
	             	configure.MapHub<MentiHub>("/hubs/menti");
	            });
	        Basic Hub method examples
	        	public static int ViewCount { get; set; } = 0;
		        public async Task NotifyWatching()
		        {
		            ViewCount++;

		            // notify EVERYONE about new view count
		            await Clients.All.SendAsync("viewCountUpdate", ViewCount);
		        }
		        public async Task SendMessage(string user, string message)
		        {
		            await Clients.All.SendAsync("ReceiveMessage", user, message);
		        }

		Hub send message to all clients
			Clients.All.SendAsync("name", param1, param2) - Sends event to clients
			Clients.Caller.SendAsync() - A Caller only send back to A caller, same client that sent the request
			Clients.Others.SendAsync() - Sends back to all except A caller. Update for everyone else
			Clients.AllExcept("C","E").SendAsync() - Sends to all except
			Clients.Client("D").SendAsync() - Sends to one particular client
			Client.Clients("D", "F").SendAsync() - Send to array/list of clients
			Clients.User("kevin").SendAsync() - Specify client using asp.net identity
			Clients.Group("Orange").SendAsync() - Send to Groups of clients. Highly encouraged!
			Clients.GroupExcept("Orange", "E").SendAsync() - Send to group except client in group
			Clients.Groups("Orange", "Yellow").SendAsync() - Send to multible groups
			Clients.OthersInGroup("yellow").SendAsync() - All other Group members except 	

ACCESSING AND UPDATING HUB FROM INSIDE WEBAPI CONTROLLER, OR ANYWHERE ELSE FOR THAT MATTER
	Just dependency inject it into the controller
	IHubContext<NameHub> hubContext
	_HubContext;

	await _HubContext.Clients.All.SendAsync("UpdateVotes", votes);

Connection Events
	Resync 
		The client should always assume it's out of date, and the server should assume the client is out of date. Never trust the client.
	CLIENT
		How to autoreconnect to Signal R, Reestabllishing connection automatically when disconnection accurs
			when you establish connection. Just do
				.withAutomaticReconnect([0, 10, 30, 60, 90]) - it tries 4 times
				.withAutomaticReconnect() - 
		connection.onreconnected((connectionId: string) => {}) - When reconnected
		connection.onreconnecting((connectionId: Error) => {}) - During attemting Reconnection
		connection.onclose((error: Error) => {}) - Fires when connection 
	SERVER
		public async override Task OnConnectedAsync() - Runs automatically every time a new client connects
		{
			ex viewCount++;
			await this.Clients.All.SendAsync("", viewCount);
			await base.OnConnectedAsync();
		}
		public async override Task OnDisconnectedAsync(Exception exception) - Runs auto every time client disconnects
		{
			ex viewCount--;
			await this.Clients.All.SendAsync("", viewCount);
			await base.OndisconnectedAsync(exception)
		}

Examples
	Ex We want the server to give us the current time
		SERVER - HostedService folder
			The hub is just an empty hub TimeHub.cs

			public class TimeService : IHostedService, IDisposable
			ctor (import the hub IHubContext<TimeHub>)

			Dispose
				timer?.Dispose();

			StartAsync
				timer = new Timer(Tick, null, 0, 500);
				return Task.CompletedTask;

			void Tick
				var currenttime = DateTime.UtcNow.ToString("F");

				timeHub.clients.all.SendAsync("updateCurrentTime", currentTime) - You literally just "Extend" the hub here and access it

			StopAsync
				timer?.Change(Timeout.Infinite, 0);

				return Task.CompletedTask;

		CLIENT
			Listening for updateCurrentTime

		program.cs
			services.AddHostedService<TimeService>();


Configure Logging
	.configureLogging(signalR.LogLevel.Trace)
    .configureLogging(new CustomLogger())

	.ConfigureLogging(logging => {
        logging.AddFilter("Microsoft.AspNetCore.SignalR", LogLevel.Trace);
        logging.AddFilter("Microsoft.AspNetCore.Http.Connections",LogLevel.Trace);
    })

    let connection = new signalR.HubConnectionBuilder()
    //.configureLogging(signalR.LogLevel.Trace)
    .configureLogging(new CustomLogger())
    .withUrl("/hubs/stringtools", { 
        transport: signalR.HttpTransportType.WebSockets | 
        signalR.HttpTransportType.ServerSentEvents}) //here you can pass in transportoptions, fallbacks
    .build();


Strongly typed hub names - Fantastic instead of magic strings
	create an interface IHubClient with Task Name(int viewCount)

	then make the hub generic viewHub : Hub<IHubClient>

	If i then need to do a namechange across my application i can just do it through the interface


With .net identity
	[Authorize(Roles = "ADMIN")] - You can authorize certain methods in hub or even the entire hub
	If not authenticated to the hub you can't even connect to the hubs
	This way you can finepick cases for hub, ex authorized for the hub but admin role for certain commands

	Handling identity errors on client side
		connection.invoke("changeBackground", "green").then(() => { }, (error) => { alert(error) });


BackPlane - Redis Cache
	What if different clients are connected to different servers?
	Two servers communicate between each other using backplane
	one server can send to all clients connected to server and to another server using backplane.
	setup
		Microsoft.AspNetCore.SignalR.StackExchangeRedis
		You need a rediscache - Similar to creating a database
		var connectionString = "Redis cache connection string";

		services.AddSignalR().AddStackExchangeRedis(connectionString);

		via the backplane they can now communicate with eachother
	You can also pass in other configuration options
		configure.Configuration.ChannelPrefix = "signalr";
		configure.Configuration.DefaultDatabase = 5; - Database number 5 on redis

Message Pack
	It's like json but fast and small. If you compress it down to bits, it compresses down
	All you have to do is enable it on the client and the server REALLY SIMPLE!

	setup	
		npm i @microsoft/signalr-protocol-msgpack
		Microsoft.AspnetCore.SignalR.Protocols.MessagePack
	CLIENT
		import { MessagePackHubProtocol } from "@microsoft/signalr-protocol-msgpack";
		when creating connection
			.withHubProtocol(new MessagePackHubProtocol()) - This makes you communicate via messagepack
	SERVER	
		services.AddSignalR().AddMessagePackProtocol(); - It adds an option in signal r for messagepack or json