C#
Strings & Chars
	StringBuilder(str) - Stringbuilder is mutable
		sb.Append(c) / += - Add to string
		str1[i] == '-' && str1[i]+1 == 'b' - Check for keyword -b
		str.Length
	.ToString() - string (OBS strings are immutable)
		string.Join("", str) - Stringarray join
		str.Remove(i-2, 5) - Remove at index and 5 characters forward
		str.ToLower() - 
		str.Split(" ") - REMOVES ALL BLANKSPACE / REMOVES matching input
		str.Split('.')[0] - RETURN ALL STRING BEFORE MATCHING CHAR (Useful for selection splits)
		str.Split(new string[] {"   "}, StringSplitOptions.None) - TO SPLIT based on STRING value instead of char
		str.Replace("-", " ") - REPLACE MATCHING CHAR with NEW CHAR
		str.Replace("   ", " / ") - Great before split ' ' for example. so the / gets it's own part in the string[] for example
		str.Contains(char) - CHECK IF STRING CONTAINS char
		str.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) - CHECK IF STRING CONTAINS char IGNORE CASE SENSITIVITY
		str.Substring(IndexToCutAt, sizeOfCutInLength) - CUTS STRING FROM INDEX to SPECIFIED SIZE
		str.Substring(str.Length -4); - SELECT LAST 4 STRINGS
		str.Substring(0, word.Length -4); - SELECT ALL CHARS BEFORE LAST 4
		str.Substring(1) - RETURNS EVERY CHARACTER AFTER CHARACTER 1
		str.Select(word => char.ToUpper(word[0]) + word.Substring(1)) - CAPITALIZES First letter of each arr
		str.Trim() - Removes all trailing and leading whitespace from string
	Chars - (normally use linq or for loops, but can do ToCharArray())
		char.IsLetterOrDigit(chr) - Check for LETTER or 
		char.IsLower() - Check If CHAR IS LOWER

Collections & Arrays
	.ToArray() - Converts List,String or whatever to Array
		Array.Sort(arr) - Sorts array. Use list reverse instead, much nicer
		Array.Reverse(arr) - Reverses array. Use list reverse instead, much nicer
		Array.FindIndex(nums, row => row == target) - RETURN INDEX OF TARGET VALUE WORKS FOR NUMBERS!

	.ToList(); - Help you with manipulation all things linq. Simple Conversion
		arr.Dump() - Console.WriteLine for collections
		arr.OfType<int> - in mixed collection returns only the specified type
		Enumerable.Range(0, object.length) - RETURNS ARR WITH LENGTH OF OBJECT, acts like a for loop that you can nest linq commands into
			int start, int count
		Enumberable.Repeat(0, 100) - Repeats first value 100 times
		Enumberable.Empty<int>() - Give an empty IEnumerable 
		arr.FindIndex(x => x == 1) - RETURNS the INDEX
		arr.IndexOf("-B"); - RETURNS the INDEX OF CHAR 
		arr.Reverse() - REVERSE collection
		arr.Add() - ADD to list
		arr.Count(x => x == 2) - returns COUNT OF CRITERIA. Blank Means just THE COUNT.
		arr.Sort() - SORTS List
		arr.Order() - Orders list
		arr.OrderDescending() - Order descending
		arr.OrderBy(x => x.avc ? 0 : 1) - SORT By CRITERIA
		arr.OrderByDescending(x => x.avc) - SORT Descending by Criteria
		arr.ThenBy() - Chaining
		arr.ThenByDescending() - Chaining
		arr.Distinct() - GETS RID OF ALL DUPLICATES and Returns List with NON DUPLICATES
		arr.DistinctBy(x => x.id) - id for example, gets rid of all the duplicates
		arr.Contains() - RETURNS TRUE if arr CONTAINS Criteria
		arr.Contains(new Obj, new ComparerById) - For Comparing OBJECTS implement new method ex 
			ComparerById : IEQualityComparer<objecttype> return x.Id == y.Id; 
		arr.Where() - FILTER THAT RETURNS NEW COLLECTION that MATCHES CRITERIA
		arr.Where((pet, idx) => pet < 5 && SelectedIndexes.Contains(idx)) - RETURNS NEW COLLECTION with INDEX and Pet CRITERIA
		arr.Select(number => number * 2) - PROJECTS EACH ELEMENT OF COLLECTION to a different type
			arr.Select(word => word.ToUpperCase)
			arr.Select(number => number.ToString())
			arr.Select((word, idx) => $"{idx + 1}: {word}")
			arr.Select(pet => pet.Weight)
			arr.Select((line, index) => $"{index+1}: {line}"); - Replaces each "item" with "indexValue: item"
			arr.Select()
			<double> ratesList = files - Create a list of double and adds all file in filelist to it.
		      .Select(file => GetCurrencyRateFromFile(file, symbol))
		      .ToList();
		    var returnList = filesNames
		      .Select(fileName => new { FileName = fileName, RateValue = GetCurrencyRateFromFile(fileName, symbol) })
		      .Select(x => $"Date: {x.FileName.Split('.')[0]} Rate: {x.RateValue}")
		      .OrderBy(x => x.Split(':')[1]);
		arr.SelectMany(x => x) - Flattens a two dimentional collection, you use select after it to then reformat it.
		arr.Aggregate() - First it does the normal operation on first two items. Then it works like a sliding window. y gets added to x
		arr.Aggregate(10, (x, y)) - applies 10 * x example and then gets going with the sliding window
		arr.Aggregate(... , x / 2) - Do an operation on the end result of the aggregate method
		arr.Aggregate((sum, nextelement) => sum + nextelement) - 
		arr.Split(" ").Aggregate((sum, next) => next.Length > sum.Length ? next : sum) - Returns the LONGEST WORD in arr
		arr.Aggregate(enumerable.empty<int>(), (sum, next) => sum.Append(next.Length)) - Adds all Length of words to an arr
		arr Array.FindIndex(arr, x => x == target); - RETURN INDEX of TARGET. RETURNS -1 IF INDEX NOT FOUND
		arr.Single() - Returns THE ONLY ELEMENT in arr matching crieria. Othewise Throws Exception
			.GroupBy(x => x).Single(g => g.Count() % 2 == 1) - Finding a group of elements and grouping them together. In this case finding a group with an odd number of elements.
		arr.SingleOrDefault() - Returns NULL if no matching element. Otherwise throws if more than one
		arr.GroupBy() - Same as SORT BUT RETURNS IGROUPING. So YOU CAN ACCESS KEY
		arr.GroupBy(x => x.age) - Retruns IGrouping
		arr.Sum() - RETURNS SUM OF MATCHING CRITERIA. IF EMPTY RETURNS SUM OF ENTIRE ARR
		arr.sum(str.Count(ltr => ltr == vow))) - Return count of different arr matching letters
		arr.Average(str.Count(ltr => ltr == vow)) - RETURNS AVERAGE OF MATCHING CRITERIA
		arr.Concat() - ADDS MULTIBLE ARRAYS OF SAME TYPE TOGETHER, VERY USEFUL TOGETHER WITH RANGE OR INSIDE FOR LOOP
		arr.Concat(new string(' ',nFloors - i - 1), new string('*',i * 2 + 1)) - CHAINS TWO DIFFERENT STRING METHODS TOGETHER
		Enumerable.Range(0, nFloors).Select(i => create objects** - THE Range is for loop i < nFloors: .Select(i => ...) acts like result[i] = 
		arr.Skip(3) - Skips first 3 values of array
		arr.SkipLast(3) - Skips the last 3 values of array
		arr.SkipWhile() - Skips while a condition is true, then returns the rest
		arr.Skip(Math.Max(0, arr.Length - x)) - Selects
		arr.Take(3) - Take the first 3 values
		arr.TakeLast - Skips the last 3 values of array
		arr.TakeWhile - Takes all the rest of collection once predicate is false
		arr.Cast<int>() - Casts all items in collection to int
		arr.Chunk(3) - Split collection into two collections of size 3, specified size. One dimentional -> two dimentional
		arr.Any() - returns true if any item satisfies condition
		arr.All() - returns true if All items satisfies condition
		arr.Contains() - returns true if element is part of collection
		arr.Append(7) - Add item to the end of the collection
		arr.Prepend(7) - Add item to the start of the collection
		arr.Count(x => x) - Gives the number of elements in collection or .where().count() number based on condition
		arr.TryGetNonEnumeratedCount(out var count) - Gets the count after computed. 
		arr.Max(x => x.age) - finds max item or max item based on condition, max changes the actual object and that's what will return
		arr.MaxBy() - find max item based on original items if using condition
		arr.Min() - finds min item or min item based on condition, min changes the actual object and that's what will return
		arr.minBy() - find smallest item based on original items if using condition
		arr.Sum() - Sums all objects, does not work on objects
		arr.Average() - Averages 
		arr.Aggregate() - 
		arr.LongCount() - Like count but we return long
		arr.First() - return first item. if you have no items it will throw exception
		arr.FirstOrDefault() - instead of exception it returns default value, ex 0, you can also specify ex -1 inside of it
		arr.Single() - Single Expects you to only have one element in collection. Turn that single item in collection to single item
		arr.SingleOrDefault() - if collection is empty return specified default
		arr.Last() - Last element 
		arr.LastOrDefault() - instead of exception, return default value
		arr.ElementAt() - Item at index, returns item at index, throws if index not there
		arr.ElementAtOrDefault() - Returns default instead of exception if index not there
		arr.DefaultIfEmpty() - Does nothing if collection has items. Otherwise adds a default element
		arr.ToArray() - materializes collection to array
		arr.ToList() - turn to list
		arr.ToDictionary(key => key, value => value) - turn to dictionary
		arr.ToHashSet() - turn to hashset
		arr.ToLookup() - Create a lookup table based on ex age, age + grouping of person
			arr.ToLookup()[15] - Select group that is age of 15 for example
		arr.AsEnumerable() - Casts to Enumerable collection
		arr.AsQueryable() - Casts to Queryable collection
		two enumerables (collections)
			arr.Union(arr2) - combine all items with distinct values from both collections
			arr.UnionBy(arr2) - To select certain item to union by
			arr.Intersect(arr2) - combine only distinct values between the collections
			arr.IntersectBy(arr2) -
			arr.Except(arr2) - take arr1 and subtract all elements from arr2 from it
			arr.ExceptBy(arr2) - 
			arr.SequenceEqual(arr2) - returns true if the collections are equal
			arr.Zip(arr2) - create tuples with index being the first collection and value being the second collection, it ignores more.
				You can even do it with three values, three value tupil
			arr.Join(arr1 => arr1.id, arr2 => arr2.id, (person, product) => $"{person.name} bought {product.name}") - Joins
			arr.GroupJoin(arr2) - now instead of having one product, we have an ienumerable of products. So
				arr.GroupJoin(arr1 => arr1.id, arr2 => arr2.id, (person, products) => $"{person.name} bought {string.join(',', products)}")
			arr.Concat(arr2) - combine two collections together. Just adding one ontop of the other
	USEFUL CHAIN COMMANDS
		Return All Indexes Of Matching Target Value
		var indexes = nums.Select((value, index) => new { Value = value, Index = index })
	        .Where(item => item.Value == target)
	        .Select(item => item.Index);

Numbers
	Math.Abs(int) - Turns NEGATIVE values POSTIVE
	Math.Max(maxProfit, profit) - RETURNS LARGEST OF THE NUMBERS GIVEN AS INPUT PARAMETERS 
	str % 2 - CHECK FOR EVEN/UNEVEN

Dictionaries - new Dictionary<KEY, VALUE>
	dict.ContainsKey(KEY) - returns bool
	storedValues[nums[i]] = i - ADD Key and VALUE to dictionary

	foreach(KeyValuePair<char, string> kvp in dict) - Seperate value from kvp
		var value = kvp.value;
		var key = kvp.key;

HasSets - new HashSet<KEY>
	hash.Contains(num)) - Checks if HASHSet Contains
	hash.Add(num) - ADDS number to HashSet

Conversion
	type.Parse(data) - PARSES
	type.TryParse(stringValue, out int); - TIRES TO PARSE

Useful Operations
	arr.(i * 2) + i < Length / 2 - Every other index
	LP + (RP - LP) / 2 - Gives Middle point of array, or closest to middle point of array 123456 gives 3

	for (int i = nFloor - 1; i >= 0; i--) - Runs from Last Index to First Index
	arr[arr.Length-1-i] - Go through highets > lowest index right to left
	for(i) for(j) - Compare first index to all, then second to all, third e.t.c.

	if(x) {continue;} - Keep going

Declarations (since i tend to forget)
	var dict = new Dict<key, IList<string>();
	var list = new List<char>{'a','b','c'};
	string[] result = new string[5];

Some operations (since i tend to forget)
	Dict.select(x => x.value).ToList<List<string>>
	.ToList<IList<string>> Same as IList<IList<string>>
	new String('#', 5);
	new string(str1R)