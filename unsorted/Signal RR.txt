

Hub send message to all clients
	Clients.All.SendAsync("name", param1, param2) - Sends event to clients
	Clients.Caller.SendAsync() - A Caller only send back to A caller, same client that sent the request
	Clients.Others.SendAsync() - Sends back to all except A caller. Update for everyone else
	Clients.AllExcept("C","E").SendAsync() - Sends to all except
	Clients.Client("D").SendAsync() - Sends to one particular client
	Client.Clients("D", "F").SendAsync() - Send to array/list of clients
	Clients.User("kevin").SendAsync() - Specify client using asp.net identity
	Clients.Group("Orange").SendAsync() - Send to Groups of clients. Highly encouraged!
	Clients.GroupExcept("Orange", "E").SendAsync() - Send to group except client in group
	Clients.Groups("Orange", "Yellow").SendAsync() - Send to multible groups
	Clients.OthersInGroup("yellow").SendAsync() - All other Group members except mefd

	Add event listeners in client
		connection.on("hubMethod", (val) => ...) - Listens to server events

		connection.off("hubMethod") - Turns off listener for event

Add to Groups - You can be in as many groups as you want
	HUB
		await Groups.AddToGroupAsync(Context.ConnectionId, "Green") - add client to group
		await Groups.RemoveFromGroupAsync(Context.ConnectionId, "Green") - remove client to group 
	CLIENT
		connection.invoke("JoinGroup", "Yellow");

Connection Identifiers
	ConnectionId - ID for this particular connection for every client connection, it refreshes on page refresh
	UserIdentifier - with asp.net identity for example
	User - with asp.net identity
	Items - store metadata for an individual connection context
	ConnectionAborted - cancellation token, if originator cancels the request

Returning Data - BE AWARE of when working with LARGE AMOUNT OF DATA
	JSON conversion takes time!

ACCESSING AND UPDATING HUB FROM INSIDE WEBAPI CONTROLLER, OR ANYWHERE ELSE FOR THAT MATTER
	Just dependency inject it into the controller
	IHubContext<NameHub> hubContext
	_HubContext;

	await _HubContext.Clients.All.SendAsync("UpdateVotes", votes);

Connection Events
	CLIENT
		How to autoreconnect to Signal R, Reestabllishing connection automatically when disconnection accurs
			when you establish connection. Just do
				.withAutomaticReconnect([0, 10, 30, 60, 90]) - it tries 4 times
				.withAutomaticReconnect() - 
		connection.onreconnected((connectionId: string) => {}) - When reconnected
		connection.onreconnecting((connectionId: Error) => {}) - During attemting Reconnection
		connection.onclose((error: Error) => {}) - Fires when connection 
	SERVER
		public async override Task OnConnectedAsync() - Runs automatically every time a new client connects
		{
			ex viewCount++;
			await this.Clients.All.SendAsync("", viewCount);
			await base.OnConnectedAsync();
		}
		public async override Task OnDisconnectedAsync(Exception exception) - Runs auto every time client disconnects
		{
			ex viewCount--;
			await this.Clients.All.SendAsync("", viewCount);
			await base.OndisconnectedAsync(exception)
		}

Resync 
	The client should always assume it's out of date, and the server should assume the client is out of date. Never trust the client.

Strongly typed hub names - Fantastic instead of magic strings
	create an interface IHubClient with Task Name(int viewCount)

	then make the hub generic viewHub : Hub<IHubClient>

	If i then need to do a namechange across my application i can just do it through the interface


With .net identity
	[Authorize(Roles = "ADMIN")] - You can authorize certain methods in hub or even the entire hub
	If not authenticated to the hub you can't even connect to the hubs
	This way you can finepick cases for hub, ex authorized for the hub but admin role for certain commands

	Handling identity errors on client side
		connection.invoke("changeBackground", "green").then(() => { }, (error) => { alert(error) });

BackPlane - Redis Cache
	What if different clients are connected to different servers?
	Two servers communicate between each other using backplane
	one server can send to all clients connected to server and to another server using backplane.
	setup
		Microsoft.AspNetCore.SignalR.StackExchangeRedis
		You need a rediscache - Similar to creating a database
		var connectionString = "Redis cache connection string";

		services.AddSignalR().AddStackExchangeRedis(connectionString);

		via the backplane they can now communicate with eachother
	You can also pass in other configuration options
		configure.Configuration.ChannelPrefix = "signalr";
		configure.Configuration.DefaultDatabase = 5; - Database number 5 on redis

Hosted Services - 
	We want the server to give us the current time
	SERVER - HostedService folder
		The hub is just an empty hub TimeHub.cs

		public class TimeService : IHostedService, IDisposable
		ctor (import the hub IHubContext<TimeHub>)

		Dispose
			timer?.Dispose();

		StartAsync
			timer = new Timer(Tick, null, 0, 500);
			return Task.CompletedTask;

		void Tick
			var currenttime = DateTime.UtcNow.ToString("F");

			timeHub.clients.all.SendAsync("updateCurrentTime", currentTime) - You literally just "Extend" the hub here and access it

		StopAsync
			timer?.Change(Timeout.Infinite, 0);

			return Task.CompletedTask;

	CLIENT
		Listening for updateCurrentTime

	program.cs
		services.AddHostedService<TimeService>();

Use .NET Client
	setup
		Microsoft.AspNetCore.SignalR.Client

	connection setup
		var connection = new ConnectionBuilder()
			.WithUrl("full path/hub/background")
			.Build();

		Client Listener
			connection.On<string>("changeBackground", (color) => {
				set ... to color...
			})

		Send from client to server
			await connection.SendAsync("ChangeBackground", "red")

		await connection.StartAsync();

		await connection.StopAsync(); - If you want to stop the thang

Multible hubs - Math to consider. - Now if you want to connect to multible hubs

Real Production
	Connection Pool is always a problem you run into. So Azure Service Helps you so much
	blinks red in traumatic event. Seriously incredible app

Message Pack
	It's like json but fast and small. If you compress it down to bits, it compresses down
	All you have to do is enable it on the client and the server REALLY SIMPLE!

	setup	
		npm i @microsoft/signalr-protocol-msgpack
		Microsoft.AspnetCore.SignalR.Protocols.MessagePack
	CLIENT
		import { MessagePackHubProtocol } from "@microsoft/signalr-protocol-msgpack";
		when creating connection
			.withHubProtocol(new MessagePackHubProtocol()) - This makes you communicate via messagepack
	SERVER	
		services.AddSignalR().AddMessagePackProtocol(); - It adds an option in signal r for messagepack or json


The idea of streaming service, you need to make sure you are beginning the stream at the BEGINNING of the file, moving forward


Azure Signal R Service - Instead of signal R directly through servers, the signalR service takes alot of the load
	
