Basics
	export const functionName = async () => {...}
	export CustomType type = {}
	export default const FunctionName = () => {}
	export default FunctionName; - At the end of the ts file

	import '../file.svg'
	import {destructuredthing} from './greeter.js';
	import * as greeter from './greeter.js'
	<script type="module" src="greeter.js">  - Module always loads after html loads

Destructuring objects
	with curly braces you get the values out of the object as direct variables 
	[first, second ...theRest] = person.languages; - Destructuring array
	{firstName, lastName} = person; - Destructuring Object

Basic gotchas
	function() vs function - function() runs the function imediately wheras function does it after 
	Don't use the Any* type! & Don't define types everywhere. Typescript knows alot of times!
	value: type - Reversed way of c# remember the :

Callbacks
	Promise Pattern
		Inside async functions you create and return a promise<Type>
			new Promise(resolve, reject => {res,rej..}) - Promise has a resolve and reject value which it returns
				resolve() - success, it returns whatever Promise<Type> that it should return
				reject('message') - failure, it returns an Error object where you can specify

		When you call the async function you .then and .catch the promise responses and handle them
			asyncOperation(input)
				.then(result => {...}) - This is the promise resolve return. You can obviously chain with return
				.then(result2 => )
				.catch(error => {... console.error('Error: ', error.message)}) - To catch the promise error
	Await Pattern
		Same return promise inside async function as with the Promise Pattern
		When Handling calling the async function instead of .then .catch
			try{
				var result = await roundToIntegerPromise(input);
			} catch(error) {
				console.error('Error: ', error.message);
			}
		You can also just skip the trycatch and just return the error message to console in the promise itself
			Inside Function -> reject(console.error('Rounding failed'))
			var result = await roundToIntegerPromise(input)
	Callback Pattern (Older)
		function fetchData(callback: (data: string) => void): void {
		    setTimeout(() => {
		        const data = "Sample data";
		        callback(data); - Without calling the function passed in anonymous function with console.log will not excecute after operations of this function.
		    }, 1000);
		}

		fetchData((data) => { - We pass in an anonymous function that will execute when called from the fetchdata function
		    console.log(data);
		});
Variables
	const post: Post[] - [{id: number, }]
	number[], string[], Array<number>
	const Name: Type | null = ... - It can be two types, type of Type and type of null
	const Name = (amount: number | { amount: number }) - Can either contain a number, or an object with number inside it
Types
	type Props = {name: string, excecute: (data) => void}
	type MathOperation = (x: number) => number; - function type
	interface CustomInterface {first: number; second: number;}
	enum Direction {Up = 1, Down}
	Union Types / Function types - They can be multible values
		role: 'admin' | 'user' | 'super-admin';
		type ErrorOrResultCallback = (err: Error | null, result?: number) => void;
	interface User extends Person, Id {} - inheritance
	type MyType = Omit<user, "id"> - Excludes the Id
	type MyType = Omit<User, "firstName" | "lastName"> - Exclude firstname or lastname 
	type FocusListener = (isFocused: boolean) => void; - function type

Error Handling
	try{
		...
	} catch(e){
		return (e as Error).message;
	}

	try{
		...
	} catch(e){
		if(e instanceof Error){ - Check if its a typeof
			return e.messagE;
		}
	}

Event Handling
	e: FormEvent<HTMLFormElement>
	const target = e.currentTarget as HTMLFormElement;

Strings & Chars
	´${Variable}´
	\n \' \\ - Linebreak, single quote, singlebackslash
	let stringbuilder = [];
			sb.push(c) - Append - Add to string
			sb.join('') - Append - Convert the array to string
	str.toString() - ToString - Convert to string (Note: strings are immutable in JavaScript)
		str[i] === '-' && str[i + 1] === 'b' - Check for keyword -b - Check for keyword -b
		str.length - Length - Get the length of the string
		str.toUpperCase() - ToUpper - Converts all string to upper
		str.toLowerCase() - ToLower - Converts all string to lower
		strArray.join("") - Join - Stringarray join
		str.slice(i-2, i-2 + 5) - Remove - Remove at index and 5 characters forward
		str.split(" ") - Split - Removes all whitespace / removes matching input
			str.split(';') - Splits at ; mark
			str.split('') - Removes whitespace
			str.split('.')[0] - Split - Returns all string before matching char (useful for selection splits)
			str.split("   ") - Split - To split based on string value instead of char
		str.replace("-", " ") - Replace - Replace matching char with new char
			str.replace("   ", " / ") - Replace - Great before split ' ' for example. so the / gets its own part in the string[] for example
		str.includes(charinput) - Contains - Check if string contains char
		new RegExp(searchTerm, 'i').test(str) - Contains - Check if string contains char ignore case sensitivity
		str.substring(IndexToCutAt, IndexToCutAt + sizeOfCutInLength) - Substring - Cuts string from index to specified size
		str.slice(-4) - Substring - Select last 4 strings
		str.slice(0, str.length - 4) - Substring - Select all chars before last 4
		str.substring(1) - Substring - Returns every character after character 1
		str.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ') - Select - Capitalizes first letter of each word
		str.trim() - Trim - Removes all trailing and leading whitespace from string
		str.join() - Join a string back together

	Chars - (normally use linq or for loops, but can do ToCharArray())
		/[a-zA-Z0-9]/.test(chr) - IsLetterOrDigit - Check for LETTER or DIGIT
		chr === chr.toLowerCase() - IsLower - Check if CHAR IS LOWER
		chr.padStart(20) - PadLeft - Add padding 20 spaces to the left
		chr.padEnd(2) - PadRight - Add padding 2 spaces to the right


Collections & Arrays
	Array.from(arr) - ToArray - Converts List, String, or whatever to Array
	arr.sort() - Array.Sort - Sorts array. Use list sort instead, much nicer
	arr.reverse() - Array.Reverse - Reverses array. Use list reverse instead, much nicer
	arr.findIndex(row => row === target) - Array.FindIndex - RETURN INDEX OF TARGET VALUE, WORKS FOR NUMBERS!
	arr.filter(x => typeof x === 'number') - OfType<int> - in mixed collection returns only the specified type
	Array.from({ length: object.length }, (_, i) => i) - Enumerable.Range - RETURNS ARR WITH LENGTH OF OBJECT
	Array(100).fill(0) - Enumerable.Repeat - Repeats first value 100 times
	[] - Enumerable.Empty<int> - Give an empty array
	arr.findIndex(x => x === 1) - FindIndex - RETURNS the INDEX
	arr.indexOf("-B") - IndexOf - RETURNS the INDEX OF CHAR 
	arr.reverse() - Reverse - REVERSE collection
	arr.push(/* element to add */) - Add - ADD to list
	arr.filter(x => x === 2).length - Count - returns COUNT OF CRITERIA
	arr.length - Count (no criteria) - returns TOTAL COUNT
	arr.sort() - Sort - SORTS List
	arr.sort() - Order - Orders list
	arr.sort((a, b) => b - a) - OrderDescending - Order descending
	arr.sort((a, b) => (a.avc ? 0 : 1) - (b.avc ? 0 : 1)) - OrderBy - SORT By CRITERIA
	arr.sort((a, b) => (b.avc ? 1 : 0) - (a.avc ? 1 : 0)) - OrderByDescending - SORT Descending by Criteria
	arr.sort((a, b) => a.criteria1 - b.criteria1).sort((a, b) => a.criteria2 - b.criteria2) - ThenBy - Chaining
	arr.sort((a, b) => b.criteria1 - a.criteria1).sort((a, b) => b.criteria2 - a.criteria2) - ThenByDescending - Chaining
	[...new Set(arr)] - Distinct - GETS RID OF ALL DUPLICATES and Returns List with NON DUPLICATES
	arr.filter((v, i, a) => a.findIndex(t => (t.id === v.id)) === i) - DistinctBy - gets rid of all the duplicates by criteria
	arr.includes(/* element to check */) - Contains - RETURNS TRUE if arr CONTAINS Criteria
	arr.some(x => new ComparerById().equals(x, newObj)) - Contains - For Comparing OBJECTS implement new method
	arr.filter(x => x.criteria) - Where - FILTER THAT RETURNS NEW COLLECTION that MATCHES CRITERIA
		arr.filter((pet, idx) => pet < 5 && SelectedIndexes.includes(idx)) - Where - RETURNS NEW COLLECTION with INDEX and Pet CRITERIA
	str.split('').filter(ch => !"aeiouAEIOU".includes(ch)).join('') - Where - Check for each character if it matches the string. Similar to foreach
	arr.map(number => number * 2) - Select - PROJECTS EACH ELEMENT OF COLLECTION to a different type
		arr.map(word => word.toUpperCase()) - Select - Projects to uppercase
		arr.map(number => number.toString()) - Select - Projects to string
		arr.map((word, idx) => `${idx + 1}: ${word}`) - Select - Projects with index
		arr.map(pet => pet.weight) - Select - Projects to pet weight
		arr.map((line, index) => `${index+1}: ${line}`) - Select - Replaces each "item" with "indexValue: item"
	let ratesList = files.map(file => getCurrencyRateFromFile(file, symbol)); - Select - Create a list of double and adds all file in filelist to it
	let returnList = fileNames
	  .map(fileName => ({ FileName: fileName, RateValue: getCurrencyRateFromFile(fileName, symbol) }))
	  .map(x => `Date: ${x.FileName.split('.')[0]} Rate: ${x.RateValue}`)
	  .sort((a, b) => a.split(':')[1] - b.split(':')[1]); - Select - Projects and orders by criteria
	arr.flat() - SelectMany - Flattens a two-dimensional collection
	arr.reduce((x, y) => x + y) - Aggregate - First it does the normal operation on first two items. Then it works like a sliding window.
	arr.reduce((x, y) => x + y, 10) - Aggregate - applies 10 * x example and then gets going with the sliding window
		arr.reduce((x, y) => x / 2, initialValue) - Aggregate - Do an operation on the end result of the aggregate method
		arr.reduce((sum, nextelement) => sum + nextelement) - Aggregate - Sums all elements
		arr.split(" ").reduce((sum, next) => next.length > sum.length ? next : sum) - Aggregate - Returns the LONGEST WORD in arr
		arr.reduce((sum, next) => [...sum, next.length], []) - Aggregate - Adds all lengths of words to an array
	arr.findIndex(x => x === target) - Array.FindIndex - RETURN INDEX of TARGET. RETURNS -1 IF INDEX NOT FOUND
	arr.find(x => criteria) - Single - Returns THE ONLY ELEMENT in arr matching criteria. Otherwise, throws an exception
	arr.filter(x => criteria).length === 1 ? arr.find(x => criteria) : null - SingleOrDefault - Returns NULL if no matching element. Otherwise, throws if more than one
	arr.reduce((groups, item) => {
	    const group = item.age;
	    if (!groups[group]) groups[group] = [];
	    groups[group].push(item);
	    return groups;
	}, {}) - GroupBy - Same as SORT BUT RETURNS IGROUPING. So YOU CAN ACCESS KEY
	arr.reduce((sum, x) => sum + x, 0) - Sum - RETURNS SUM OF MATCHING CRITERIA. IF EMPTY RETURNS SUM OF ENTIRE ARR
	str.split("").reduce((sum, ltr) => sum + (ltr === vow ? 1 : 0), 0) - Sum - Return count of different arr matching letters
	str.split("").reduce((sum, ltr, _, arr) => sum + (ltr === vow ? 1 : 0) / arr.length, 0) - Average - RETURNS AVERAGE OF MATCHING CRITERIA
	arr.concat(...arrays) - Concat - ADDS MULTIPLE ARRAYS OF SAME TYPE TOGETHER
	arr.concat(Array(nFloors - i - 1).fill(' '), Array(i * 2 + 1).fill('*')) - Concat - CHAINS TWO DIFFERENT STRING METHODS TOGETHER
	Array.from({ length: nFloors }, (_, i) => createObjects(i)) - Enumerable.Range - THE Range is for loop i < nFloors: .Select(i => ...) acts like result[i]
	arr.slice(3) - Skip - Skips first 3 values of array
	arr.slice(0, -3) - SkipLast - Skips the last 3 values of array
	arr.slice(arr.findIndex(x => !condition)) - SkipWhile - Skips while a condition is true, then returns the rest
	arr.slice(Math.max(0, arr.length - x)) - Skip - Skips the last x values of array
	arr.slice(0, 3) - Take - Take the first 3 values
	arr.slice(-3) - TakeLast - Takes the last 3 values of array
	arr.filter(condition) - TakeWhile - Takes all the rest of collection once predicate is false
	arr.map(Number) - Cast<int> - Casts all items in collection to int
	arr.reduce((resultArray, item, index) => { const chunkIndex = Math.floor(index / 3); if (!resultArray[chunkIndex]) resultArray[chunkIndex] = []; resultArray[chunkIndex].push(item); return resultArray; }, []) - Chunk - Split collection into chunks of size 3
	arr.some(condition) - Any - Returns true if any item satisfies condition
	arr.every(condition) - All - Returns true if all items satisfy condition
	arr.includes(element) - Contains - Returns true if element is part of collection
	arr.concat(7) - Append - Add item to the end of the collection
	[7].concat(arr) - Prepend - Add item to the start of the collection
	arr.filter(x => x).length - Count - Gives the number of elements in collection or based on condition
	arr.length - TryGetNonEnumeratedCount - Gets the count after computed
	Math.max(...arr.map(x => x.age)) - Max - Finds max item or max item based on condition
	arr.reduce((max, x) => condition(x) > condition(max) ? x : max) - MaxBy - Finds max item based on original items if using condition
	Math.min(...arr.map(x => x.age)) - Min - Finds min item or min item based on condition
	arr.reduce((min, x) => condition(x) < condition(min) ? x : min) - MinBy - Finds smallest item based on original items if using condition
	arr.reduce((sum, x) => sum + x, 0) - Sum - Sums all objects
	arr.reduce((sum, x, _, { length }) => sum + x / length, 0) - Average - Averages
	arr.reduce((x, y) => x + y) - Aggregate - Aggregates with operation
	arr.length - LongCount - Like count but returns long
	arr[0] - First - Return first item. Throws exception if no items
	arr[0] || defaultValue - FirstOrDefault - Return first item or default value if no items
	arr.length === 1 ? arr[0] : throw new Error() - Single - Returns the only element in collection. Throws exception if more than one
	arr.length === 1 ? arr[0] : defaultValue - SingleOrDefault - Returns the only element or specified default if no items
	arr[arr.length - 1] - Last - Last element
	arr[arr.length - 1] || defaultValue - LastOrDefault - Returns last element or default value if no items
	arr[index] - ElementAt - Returns item at index. Throws if index not there
	arr[index] || defaultValue - ElementAtOrDefault - Returns item at index or default value if index not there
	arr.length ? arr : [defaultValue] - DefaultIfEmpty - Does nothing if collection has items. Otherwise adds a default element
	Array.from(arr) - ToArray - Materializes collection to array
	arr.slice() - ToList - Turn to list
	Object.fromEntries(arr.map(key => [key, key])) - ToDictionary - Turn to dictionary
	new Set(arr) - ToHashSet - Turn to hashset
	arr.reduce((lookup, item) => { const key = item.age; if (!lookup[key]) lookup[key] = []; lookup[key].push(item); return lookup; }, {}) - ToLookup - Create a lookup table based on ex age, age + grouping of person
	arr.reduce((lookup, item) => { const key = item.age; if (!lookup[key]) lookup[key] = []; lookup[key].push(item); return lookup; }, {})[15] - ToLookup()[15] - Select group that is age of 15 for example
	arr - AsEnumerable - Casts to Enumerable collection
	arr - AsQueryable - Casts to Queryable collection
	two enumerables (collections)
		[...new Set([...arr, ...arr2])] - Union - Combine all items with distinct values from both collections
		[...new Set([...arr, ...arr2].map(item => item.key))] - UnionBy - Combine items by certain key with distinct values
		arr.filter(value => arr2.includes(value)) - Intersect - Combine only distinct values between the collections
		arr.filter(a => arr2.some(b => a.key === b.key)) - IntersectBy - Combine only distinct values by key between collections
		arr.filter(value => !arr2.includes(value)) - Except - Take arr1 and subtract all elements from arr2 from it
		arr.filter(a => !arr2.some(b => a.key === b.key)) - ExceptBy - Take arr1 and subtract all elements by key from arr2 from it
		JSON.stringify(arr) === JSON.stringify(arr2) - SequenceEqual - Returns true if the collections are equal
		arr.map((value, index) => [value, arr2[index]]) - Zip - Create tuples with index being the first collection and value being the second collection
		arr.map((value, index) => [value, arr2[index], arr3[index]]) - Zip (three values) - Create tuples with three values
		arr.map(person => ({ ...person, product: arr2.find(product => product.id === person.id) }))
		    .filter(x => x.product)
		    .map(({ name, product }) => `${name} bought ${product.name}`) - Join - Joins based on condition
		arr.map(person => ({ ...person, products: arr2.filter(product => product.id === person.id) }))
		    .map(({ name, products }) => `${name} bought ${products.map(p => p.name).join(',')}`) - GroupJoin - Group joins based on condition
		arr.concat(arr2) - Concat - Combine two collections together by adding one on top of the other
	USEFUL CHAIN COMMANDS
		Return All Indexes Of Matching Target Value
			let indexes = nums
			  .map((value, index) => ({ value, index })) - Select - Projects each element with its index
			  .filter(item => item.value === target) - Where - Filters items matching target value
			  .map(item => item.index); - Select - Projects the indexes of the filtered items


Numbers
	Math.abs(num) - Abs - Turns NEGATIVE values POSITIVE
	Math.max(maxProfit, profit) - Max - RETURNS LARGEST OF THE NUMBERS GIVEN AS INPUT PARAMETERS
	num % 2 === 0 - Even - CHECK FOR EVEN
	num % 2 !== 0 - Uneven - CHECK FOR UNEVEN
	Math.random() - Generates a random number between 0 and 1
	Math.Ceil() - 
	Math.Floor() - 
	Math.PI() - Gives value of Pi
	Math.Pow() - PowerOf
	Math.abs() - absolute number
	Math.sin() - sin

Dictionaries - let dict = new Map(); - new Dictionary<KEY, VALUE> - Creates a new dictionary
	dict.has(KEY) - ContainsKey - Returns bool if key exists

	dict.set(nums[i], i) - ADD Key and VALUE to dictionary - Adds key and value to dictionary

	for (let [key, value] of dict) { - foreach(KeyValuePair<char, string> kvp in dict) - Separate value from kvp
	  let key = key; - var key = kvp.key;
	  let value = value; - var value = kvp.value;
	}

HasSets - let hashSet = new Set(); - new HashSet<KEY> - Creates a new HashSet
	hashSet.has(num) - Contains - Checks if HashSet contains
	hashSet.add(num) - Add - Adds number to HashSet
	
Conversion
	parseInt(data) - Parse - PARSES string to integer
	let tryParse = (str, outVar) => { outVar.value = parseInt(str); return !isNaN(outVar.value); };
	let success = tryParse(stringValue, parsedInt = {}); - TryParse - TRIES TO PARSE

Useful Operations
	arr.filter((_, i) => (i * 2) + i < Length / 2) - Every other index - Filters every other index
	Math.floor(LP + (RP - LP) / 2) - Middle point - Gives middle point of array, or closest to middle point of array

	for (let i = nFloor - 1; i >= 0; i--) { - Runs from Last Index to First Index
	  // your code here
	}

	arr[arr.length - 1 - i] - Highest to lowest - Go through highest > lowest index right to left

	for (let i = 0; i < arr.length; i++) { - for(i) - Compare first index to all
	  for (let j = 0; j < arr.length; j++) { - for(j) - Compare each index to all
	    // your code here
	  }
	}

	if (x) { continue; } - Keep going - Continue to next iteration if condition is true

Declarations (since i tend to forget)
	let dict = new Map(); - var dict = new Dict<key, IList<string>(); - Declaration for dictionary
	let list = ['a', 'b', 'c']; - var list = new List<char>{'a','b','c'}; - Declaration for list
	let result = new Array(5).fill(""); - string[] result = new string[5]; - Declaration for string array

Some operations (since i tend to forget)
	[...dict.values()] - Dict.select(x => x.value).ToList<List<string>> - Get list of dictionary values as a list
	Array.from(dict.values()) - .ToList<IList<string>> - Get list of dictionary values as IList<IList<string>>
	'#'.repeat(5) - new String('#', 5); - Create a new string with '#' repeated 5 times
	[...str1R].join('') - new string(str1R) - Create a new string from an array of characters


DOM Basic Operations
	Basic Selection & Manipulation
		Creating Selectors for DOM elements
			document.getElementById("elementId") as HTMLDivElement
			document.querySelector<HTMLDivElement>(".className")
			document.querySelectorAll<HTMLDivElement>(".className")
		Individual element properties
			obj.offsetTop - distance between top of object and top of window
			obj.offsetLeft - distance between left of object and left of window
			obj.clientTop - distance between object and next object inside it from top
			obj.clientLeft - distance between object and next object inside it from left
			obj.offsetWidth - Entire width of object
			obj.offsetHeight - Entire height of object
			obj.clientWidth - Width of object inside
			obj.clientHeight - Height of object inside
			obj.scrollHeight - Entire height of content in scroll
			obj.scrollTop - Height of current Scrollheight based on how far from top
			obj.scrollTo(x, y) or {top: 50, behavior: 'smooth'} - Scroll fixed pixels
			obj.scrollBy(x, y) or {top: 50, behavior: 'smooth'} - Scroll relative pixels
			obj.scrollIntoView({behavior: 'smooth'}) - Make a specific element scroll into view
		Changing Parameters
			obj.innerHTML + ` ` - Replace html of object
			obj.innerHTML += ` ` - Append html of object
			obj.innerText - Replace text value inside object
			obj.click() - Simulate click event
			obj.classList.add("") - Add class to object
			obj.style.cssText = - Add css styling to object
		Creating Elements
			document.createElement("h1") - Create brand new html element
			obj.appendChild(element) - Append a new html element to object
			obj.remove(); - Remove element from html
	Actions
		Event Listeners
			input.addEventListener('change', (event: Event) => {
			  const target = event.target as HTMLInputElement;
			  ...
			});

			const handleInputChange = (event: Event): void => {
			  const target = event.target as HTMLInputElement;
			  ...
			};
			input.addEventListener('change', handleInputChange);
		EventListener Events
			'animationend' - Wait for any timeline to end before doing action
			'click'
			'oncontextmenu'
			'ondbclick'
			'onchange'
			'ondrag'
			'onblur'
			'mouseenter'
			'scroll'
			'submit'
			'dragstart'
			'dragenter'
			'dragover'
	Events
		Event Object - All events have an Event object, eventhandlers return an Event object by default
		Type
			e.target as typeof e.target & {...}
		Most Common commands
			e.preventDefault() - Prevents default behavior of event, ex forms
			e.target.value - the current value of target that sent the event. target = this
			e.name.value, e.email.value - Access the Name attribute assigned to form objects
		Other commands
			e.currentTarget - the parent of where they clicked
			e.target - where they clicked originally
			e.stopPropagation() - Stops the event from propagating (bubbling) up the DOM tree
			e.clientY - Returns the Y coordinate of the event relative to the viewport.
			e.clientX - Returns the X coordinate of the event relative to the viewport.
			e.key - Returns the value of the key pressed (for keyboard events).
			e.button - Returns the button number that was pressed


DOM Types
	HTML Tags & Elements
		HTMLElement
		HTMLDivElement
		HTMLSpanElement
		HTMLInputElement
		HTMLButtonElement
		HTMLAnchorElement
		HTMLImageElement
		HTMLFormElement
		HTMLTableElement
		HTMLTableRowElement
		HTMLTableCellElement
		HTMLUListElement
		HTMLOListElement
		HTMLLIElement
		HTMLSelectElement
		HTMLOptionElement
	Event Objects
		Event - Base interface for all events.
		UIEvent - User interface actions (e.g., scrolling).
		MouseEvent - Pointing device interactions (e.g., click, mouseover).
		KeyboardEvent - Keyboard interactions (e.g., keydown, keyup).
		FocusEvent - Focus-related events (e.g., focus, blur).
		InputEvent - Input field events (e.g., input).
		ChangeEvent - Form element changes (e.g., change on <select>).
		SubmitEvent - Form submission (e.g., submit on <form>).
		TouchEvent - Touch interactions (e.g., touchstart, touchend).
		DragEvent - Drag-and-drop interactions (e.g., drag, drop).
		WheelEvent - Mouse wheel rotations (e.g., wheel).
		AnimationEvent - CSS animations (e.g., animationstart, animationend).
		TransitionEvent - CSS transitions (e.g., transitionend).
		PointerEvent - Pointing device interactions (e.g., pointerdown, pointerup).
		ClipboardEvent - Clipboard interactions (e.g., copy, paste).
	React Elements
		ReactNode - Any renderable React content.
		ReactElement - A React element, typically created with JSX.
		JSX.Element - The return type for a functional component.
		ComponentType - The type for a React component (class or function).
		FC (FunctionComponent) - Type for functional components with children.
		VFC (VoidFunctionComponent) - Type for functional components without children.
		ReactChild - A single React child (string, number, element, etc.).
		ReactFragment - A type for React fragments (<>...</>).
		PropsWithChildren - Type for props objects that include `children`.
		Dispatch - Type for a function that dispatches an action (e.g., in useReducer).
		SetStateAction - Type for a function that sets state (e.g., in useState).
		ChangeEvent - Event type for form elements.
		MouseEvent - Event type for mouse events.
		KeyboardEvent - Event type for keyboard events.
		SyntheticEvent - Base type for React events.
		RefObject - Type for creating references to DOM elements or components.
		MutableRefObject - Type for mutable references.
		Context - Type for React context.
		ProviderProps - Props type for context providers.
		RefCallback - Type for callback refs.
		ReactPortal - Type for creating React portals.
		HTMLAttributes - Attributes for standard HTML elements.
		SVGAttributes - Attributes for SVG elements.
		CSSProperties - Type for inline CSS styles.
		ErrorInfo - Information about errors in error boundaries.
		ForwardRefRenderFunction - Type for components using forwardRef.
		Reducer - Type for reducers (e.g., in useReducer).
		ReactHTMLElement - Type for React elements representing HTML.
		ReactSVGElement - Type for React elements representing SVG.
		ReactComponentElement - Type for React elements representing components.