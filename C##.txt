

for + foreach
	if(x) {continue;} - Keep going
	arr.(i * 2) + i < Length / 2 -  - EVERY OTHER INDEX
	arr[arr.Length-1-i] - GO THROUGH HIGHEST > LOWEST INDEX RIGHT TO LEFT
	for(i) for(j) - COMPARE FIRST INDEX TO ALL, THEN SECOND TO ALL, THIRD E.T.C... to find condition
	for (int i = nFloor - 1; i >= 0; i--) - For loop that runs from LAST INDEX to FIRST INDEX

new HashSet<KEY>
	hash.Contains(num)) - Checks if HASHSet Contains
	hash.Add(num) - ADDS number to HashSet

new Dictionary<KEY, VALUE>
	dict.ContainsKey(KEY) - returns bool
	storedValues[nums[i]] = i - ADD Key and VALUE to dictionary

	TARGET - VALUE = DIFFERENCE. put the - VALUE in the Dictionary. Next time DIFFERENCE is say 2 and Dictionary VALUE contains 2 We KNOW the DIFFERENCE and Dictionary VALUE become 0. so this is how we can find the value that adds up to total, or target. Or whatever.

	foreach(KeyValuePair<char, string> kvp in dict) - FOR EACH MATCHING KEY VALUE and VALUE pair - Check for stuff, add stuff e.t.c.
		str == kvp.value ?
		str == kvp.key ?
		output += kvp.key
		output += kvp.value
		break; - Add keys, values, check for matching keys, values and so on

.ToList(); - Help you with manipulation all things linq. Simple Conversion
	arr.Dump() - Console.WriteLine for collections
	arr.OfType<int> - in mixed collection returns only the specified type
	Enumerable.Range(0, object.length) - RETURNS ARR WITH LENGTH OF OBJECT, acts like a for loop that you can nest linq commands into
		int start, int count
	Enumberable.Repeat(0, 100) - Repeats first value 100 times
	Enumberable.Empty<int>() - Give an empty IEnumerable 
	arr.FindIndex(x => x == 1) - RETURNS the INDEX
	arr.IndexOf("-B"); - RETURNS the INDEX OF CHAR 
	arr.Reverse() - REVERSE collection
	arr.Add() - ADD to list
	arr.Count(x => x == 2) - returns COUNT OF CRITERIA. Blank Means just THE COUNT.
	arr.Sort() - SORTS List
	arr.Order() - Orders list
	arr.OrderDescending() - Order descending
	arr.OrderBy(x => x.avc ? 0 : 1) - SORT By CRITERIA
	arr.OrderByDescending(x => x.avc) - SORT Descending by Criteria
	arr.ThenBy() - Chaining
	arr.ThenByDescending() - Chaining
	arr.Distinct() - GETS RID OF ALL DUPLICATES and Returns List with NON DUPLICATES
	arr.DistinctBy(x => x.id) - id for example, gets rid of all the duplicates
	arr.Contains() - RETURNS TRUE if arr CONTAINS Criteria
	arr.Contains(new Obj, new ComparerById) - For Comparing OBJECTS implement new method ex 
		ComparerById : IEQualityComparer<objecttype> return x.Id == y.Id; 
	arr.Where() - FILTER THAT RETURNS NEW COLLECTION that MATCHES CRITERIA
	arr.Where((pet, idx) => pet < 5 && SelectedIndexes.Contains(idx)) - RETURNS NEW COLLECTION with INDEX and Pet CRITERIA
	arr.Select(number => number * 2) - PROJECTS EACH ELEMENT OF COLLECTION to a different type
		arr.Select(word => word.ToUpperCase)
		arr.Select(number => number.ToString())
		arr.Select((word, idx) => $"{idx + 1}: {word}")
		arr.Select(pet => pet.Weight)
		arr.Select((line, index) => $"{index+1}: {line}"); - Replaces each "item" with "indexValue: item"
		arr.Select()
	arr.SelectMany(x => x) - Flattens a two dimentional collection, you use select after it to then reformat it.
	arr.Aggregate() - First it does the normal operation on first two items. Then it works like a sliding window. y gets added to x
	arr.Aggregate(10, (x, y)) - applies 10 * x example and then gets going with the sliding window
	arr.Aggregate(... , x / 2) - Do an operation on the end result of the aggregate method
	arr.Aggregate((sum, nextelement) => sum + nextelement) - 
	arr.Split(" ").Aggregate((sum, next) => next.Length > sum.Length ? next : sum) - Returns the LONGEST WORD in arr
	arr.Aggregate(enumerable.empty<int>(), (sum, next) => sum.Append(next.Length)) - Adds all Length of words to an arr
	arr Array.FindIndex(arr, x => x == target); - RETURN INDEX of TARGET. RETURNS -1 IF INDEX NOT FOUND
	arr.Single() - Returns THE ONLY ELEMENT in arr matching crieria. Othewise Throws Exception
		.GroupBy(x => x).Single(g => g.Count() % 2 == 1) - Finding a group of elements and grouping them together. In this case finding a group with an odd number of elements.
	arr.SingleOrDefault() - Returns NULL if no matching element. Otherwise throws if more than one
	arr.GroupBy() - Same as SORT BUT RETURNS IGROUPING. So YOU CAN ACCESS KEY
	arr.GroupBy(x => x.age) - Retruns IGrouping
	arr.Sum() - RETURNS SUM OF MATCHING CRITERIA. IF EMPTY RETURNS SUM OF ENTIRE ARR
	arr.sum(str.Count(ltr => ltr == vow))) - Return count of different arr matching letters
	arr.Average(str.Count(ltr => ltr == vow)) - RETURNS AVERAGE OF MATCHING CRITERIA
	arr.Concat() - ADDS MULTIBLE ARRAYS OF SAME TYPE TOGETHER, VERY USEFUL TOGETHER WITH RANGE OR INSIDE FOR LOOP
	arr.Concat(new string(' ',nFloors - i - 1), new string('*',i * 2 + 1)) - CHAINS TWO DIFFERENT STRING METHODS TOGETHER
	Enumerable.Range(0, nFloors).Select(i => create objects** - THE Range is for loop i < nFloors: .Select(i => ...) acts like result[i] = 
	arr.Skip(3) - Skips first 3 values of array
	arr.SkipLast(3) - Skips the last 3 values of array
	arr.SkipWhile() - Skips while a condition is true, then returns the rest
	arr.Skip(Math.Max(0, arr.Length - x)) - Selects
	arr.Take(3) - Take the first 3 values
	arr.TakeLast - Skips the last 3 values of array
	arr.TakeWhile - Takes all the rest of collection once predicate is false
	arr.Cast<int>() - Casts all items in collection to int
	arr.Chunk(3) - Split collection into two collections of size 3, specified size. One dimentional -> two dimentional
	arr.Any() - returns true if any item satisfies condition
	arr.All() - returns true if All items satisfies condition
	arr.Contains() - returns true if element is part of collection
	arr.Append(7) - Add item to the end of the collection
	arr.Prepend(7) - Add item to the start of the collection
	arr.Count(x => x) - Gives the number of elements in collection or .where().count() number based on condition
	arr.TryGetNonEnumeratedCount(out var count) - Gets the count after computed. 
	arr.Max(x => x.age) - finds max item or max item based on condition, max changes the actual object and that's what will return
	arr.MaxBy() - find max item based on original items if using condition
	arr.Min() - finds min item or min item based on condition, min changes the actual object and that's what will return
	arr.minBy() - find smallest item based on original items if using condition
	arr.Sum() - Sums all objects, does not work on objects
	arr.Average() - Averages 
	arr.Aggregate() - 
	arr.LongCount() - Like count but we return long
	arr.First() - return first item. if you have no items it will throw exception
	arr.FirstOrDefault() - instead of exception it returns default value, ex 0, you can also specify ex -1 inside of it
	arr.Single() - Single Expects you to only have one element in collection. Turn that single item in collection to single item
	arr.SingleOrDefault() - if collection is empty return specified default
	arr.Last() - Last element 
	arr.LastOrDefault() - instead of exception, return default value
	arr.ElementAt() - Item at index, returns item at index, throws if index not there
	arr.ElementAtOrDefault() - Returns default instead of exception if index not there
	arr.DefaultIfEmpty() - Does nothing if collection has items. Otherwise adds a default element
	arr.ToArray() - materializes collection to array
	arr.ToList() - turn to list
	arr.ToDictionary(key => key, value => value) - turn to dictionary
	arr.ToHashSet() - turn to hashset
	arr.ToLookup() - Create a lookup table based on ex age, age + grouping of person
		arr.ToLookup()[15] - Select group that is age of 15 for example
	arr.AsEnumerable() - Casts to Enumerable collection
	arr.AsQueryable() - Casts to Queryable collection
	two enumerables (collections)
		arr.Union(arr2) - combine all items with distinct values from both collections
		arr.UnionBy(arr2) - To select certain item to union by
		arr.Intersect(arr2) - combine only distinct values between the collections
		arr.IntersectBy(arr2) -
		arr.Except(arr2) - take arr1 and subtract all elements from arr2 from it
		arr.ExceptBy(arr2) - 
		arr.SequenceEqual(arr2) - returns true if the collections are equal
		arr.Zip(arr2) - create tuples with index being the first collection and value being the second collection, it ignores more.
			You can even do it with three values, three value tupil
		arr.Join(arr1 => arr1.id, arr2 => arr2.id, (person, product) => $"{person.name} bought {product.name}") - Joins
		arr.GroupJoin(arr2) - now instead of having one product, we have an ienumerable of products. So
			arr.GroupJoin(arr1 => arr1.id, arr2 => arr2.id, (person, products) => $"{person.name} bought {string.join(',', products)}")
		arr.Concat(arr2) - combine two collections together. Just adding one ontop of the other
		




Ints
	Math.Abs(int) - Turns NEGATIVE values POSTIVE
	Math.Max(maxProfit, profit) - RETURNS LARGEST OF THE NUMBERS GIVEN AS INPUT PARAMETERS 
	str % 2 - CHECK FOR EVEN/UNEVEN

ToCharArray() / chars
	char.IsLetterOrDigit(chr) - Check for LETTER or 
	char.IsLower() - Check If CHAR IS LOWER

.ToString() - string (OBS strings are immutable)
	string.Join("", str) - Stringarray join
	str.Remove(i-2, 5) - Remove at index and 5 characters forward
	str.ToLower() - 
	str.Split(" ") - REMOVES ALL BLANKSPACE / REMOVES matching input
	str.Split('.')[0] - RETURN ALL STRING BEFORE MATCHING CHAR (Useful for selection splits)
	str.Split(new string[] {"   "}, StringSplitOptions.None) - TO SPLIT based on STRING value instead of char
	str.Replace("-", " ") - REPLACE MATCHING CHAR with NEW CHAR
	str.Replace("   ", " / ") - Great before split ' ' for example. so the / gets it's own part in the string[] for example
	str.Contains(char) - CHECK IF STRING CONTAINS char
	str.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) - CHECK IF STRING CONTAINS char IGNORE CASE SENSITIVITY
	str.Substring(IndexToCutAt, sizeOfCutInLength) - CUTS STRING FROM INDEX to SPECIFIED SIZE
	str.Substring(str.Length -4); - SELECT LAST 4 STRINGS
	str.Substring(0, word.Length -4); - SELECT ALL CHARS BEFORE LAST 4
	str.Substring(1) - RETURNS EVERY CHARACTER AFTER CHARACTER 1
	str.Select(word => char.ToUpper(word[0]) + word.Substring(1)) - CAPITALIZES First letter of each arr
	str.Trim() - Removes all trailing and leading whitespace from string


StringBuilder(str) - Easy String Manipulation and scanning
	(Most of the time just do string = ""; then +=)
	sb.Append(c) - ADD to STRING
	str1[i] == '-'
	str1[i] == '-' && str1[i]+1 == 'B' - CHECK FOR KEYWORD
	str1.stringCommands
	str1.CharCommands
	str.Length - Length of string

.ToArray() - Converts List,String or whatever to Array
	Array.Sort(arr) - Sorts array. Use list reverse instead, much nicer
	Array.Reverse(arr) - Reverses array. Use list reverse instead, much nicer
	Array.FindIndex(nums, row => row == target) - RETURN INDEX OF TARGET VALUE WORKS FOR NUMBERS!

Conversion
	type.Parse(data) - PARSES
	type.TryParse(stringValue, out int); - TIRES TO PARSE

USEFUL CHAIN COMMANDS
	RETURN ALL INDEXES OF MATCHING TARGET VALUE
		var indexes = nums.Select((value, index) => new { Value = value, Index = index })
	        .Where(item => item.Value == target)
	        .Select(item => item.Index);


Fun Little math Operations
	LP + (RP - LP) / 2 - Gives Middle point of array, or closest to middle point of array 123456 gives 3

Records
	public record - Start working with them as soon as possible!!

 
Others & unsorted information

Usings
	using System.Linq;
	using System.Collections.Generic;
	System.String.Format;

Dict.select(x => x.value).ToList<List<string>>
Dict<key, IList<string>
new List<char>{'a','b','c'}
string[] result = new string[5];
new String('#', 5);
new string(str1R)
.ToList<IList<string>> Same as IList<IList<string>>